{"meta":{"title":"Welcome to sher-wu's home !","subtitle":"","description":"","author":"sher-wu","url":"http://sher-wu.github.io","root":"/"},"posts":[{"tags":[],"title":"Donot Forget!","date":"2099/12/31","text":"Donot Forget! 费用流 KM 树套树 trie树 bitset 徐州现场赛 J 徐州现场赛 单点修改+mex P4147 玉蟾宫 (单调栈) CF 1264C CF 1264E 带权 &amp; 种类 并查集 树链剖分 HDU4747 线段树 冲鸭！","permalink":"http://sher-wu.github.io/2099/12/31/Donot%20Forget!/","photos":[]},{"tags":[{"name":"树上差分","slug":"树上差分","permalink":"http://sher-wu.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}],"title":"P3128","date":"2019/12/10","text":"P3128 [USACO15DEC] 最大流 Description Farmer John给他的牛棚的 \\(N(2\\leq N\\leq50,000)\\) 个隔间之间安装了\\(N-1\\)根管道，隔间编号从\\(1\\)到\\(N\\)。所有隔间都被管道连通了。 FJ有\\(K(1\\leq K\\leq100,000)\\)条运输牛奶的路线，第i条路线从隔间\\(s_i\\)运输到隔间\\(t_i\\)。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 Input The first line of the input contains N and K. The next N-1 lines each contain two integers x and y (\\(x \\neq y\\)) describing a pipe between stalls x and y. The next K lines each contain two integers s and t describing the endpoint stalls of a path through which milk is being pumped. Output An integer specifying the maximum amount of milk pumped through any stall in the barn. Sample Input 5 10 3 4 1 5 4 2 5 4 5 4 5 4 3 5 4 3 4 3 1 3 3 5 5 4 1 5 3 4 Sample Output 9 思路： N个节点构成了一棵树，然后在树上的边有流量，给定一条路线，其所经过的边流量都+1. 典型的含边权的树上差分。根据树上差分思想，把边的流量保存在儿子节点上，当从u到v有一条路线时，只跟u到v上所有的边有关系，而跟lca(u,v)到根的边全都无关。因而flow[u]++,flow[v]++,flow[lca(u,v)]-=2. 全部加完后，用一次DFS即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 5e4+20; int n,k; int bei[22],f[maxn],high,tot[maxn];//flow int d[maxn],fir[maxn],nex[2*maxn],to[2*maxn]; int fa[maxn][22]; inline ll read(){ ll x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x; } inline void dfs1(int now,int pre,int depth)//init for lca { d[now]=depth; fa[now][0]=pre; for(int i=1;i&lt;=20;++i) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=fir[now];i;i=nex[i]) { if(to[i]==pre) continue; dfs1(to[i],now,depth+1); } } inline int lca(int x,int y) { if(d[x]&lt;d[y]) swap(x,y); for(int i=20;i&gt;=0;--i) if(d[x]-bei[i]&gt;=d[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; } inline void dfs2(int x,int y)//add values { int l=lca(x,y); ++f[x],++f[y],--f[l],--f[fa[l][0]]; } inline void dfs3(int now,int pre)//find the point with highest value { for(int p=fir[now];p;p=nex[p]) { if(to[p]==pre) continue; dfs3(to[p],now); tot[now]+=tot[to[p]]; } tot[now]+=f[now]; if(tot[now]&gt;high) high=tot[now]; } int main() { n=read(),k=read(); bei[0]=1; for(int i=1;i&lt;=20;++i) bei[i]=bei[i-1]*2; for(int i=1;i&lt;n;++i) { int p=read(),q=read(); nex[i]=fir[p],fir[p]=i,to[i]=q; nex[n+i]=fir[q],fir[q]=n+i,to[n+i]=p; } dfs1(1,0,1); while(k--) dfs2(read(),read()); dfs3(1,0); printf(&quot;%d\\n&quot;,high); return 0; }","permalink":"http://sher-wu.github.io/2019/12/10/P3128/","photos":[]},{"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"http://sher-wu.github.io/tags/%E6%A0%88/"}],"title":"BZOJ4756","date":"2019/12/06","text":"BZOJ4756 [Usaco2017 Jan] Promotion Counting Description n只奶牛构成了一个树形的公司，每个奶牛有一个能力值pi，1号奶牛为树根。 问对于每个奶牛来说，它的子树中有几个能力值比它大的。 Input n，表示有几只奶牛 n&lt;=100000 接下来n行为1-n号奶牛的能力值pi 接下来n-1行为2-n号奶牛的经理（树中的父亲） Output 共n行，每行输出奶牛i的下属中有几个能力值比i大 Sample Input 5 804289384 846930887 681692778 714636916 957747794 1 1 2 3 Sample Output 2 0 1 0 0 Solution 如果每个节点都给一个线段树，然后暴力的在父节点将两个线段树合并，那么空间肯定是不够的。因而首先要在空间上进行优化。这里引入了树上的线段树合并。 \"树上\"还是原来的，DFS的顺序从下往上维护。 \"线段树合并\"的步骤如下（这里的线段树实际上是一个链）： 对于两颗树的节点u和v ①如果u为空，返回v ②如果v为空，返回u ③否则，新建节点t，整合u和v的信息，然后递归合并u和v的左右子树 inline int merge(int u,int v) { if(!u) return v; if(!v) return u; int t = ++cnt; sum[t]=sum[u]+sum[v]; les[t]=merge(les[u],les[v]); ris[t]=merge(ris[u],ris[v]); return t; } 思考可知，每有一个位置权值同样存在，就要\\(O(logn)\\)的复杂度。那么合并的复杂度取决于两棵线段树重合部分的大小。 由于权值线段树中被更新的位置通常很均匀分布，所以合并的两棵线段树通常具有很小的相似性。 线段树合并的空间复杂度和时间复杂度都是\\(O(nlogn)\\)的。 （点大概要开\\(2nlogn\\)个，测了一下\\(n=131072\\)‬的时候\\(32n\\)，\\(n=524288\\)的时候\\(36n\\)‬，那么\\(2e7\\)个应该是肯定够的） 后来看了网上的博客，发现其实这题有更简单的做法。。。 按DFS序把所有点放入并取出一个栈，放入时计算小于\\(a_i\\)的数量并把\\(a_i\\)放入线段树中，取出时再计算一次小于\\(a_i\\)的数量，那么两者之差就是答案。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5+20; const int maxm = 2e7+20; int n,id[maxn],a[maxn],b[maxn],fa[maxn],ans[maxn]; int cnt,pid[maxn],sum[maxm],les[maxm],ris[maxm]; vector&lt;int&gt; son[maxn]; inline ll read(){ ll x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f; } inline void readin() { n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(),b[i]=a[i]; sort(b+1,b+1+n);//题目给定了能力值互异，故不用去重 for(int i=1;i&lt;=n;++i) id[i]=lower_bound(b+1,b+1+n,a[i])-b; for(int i=2;i&lt;=n;++i) fa[i]=read(),son[fa[i]].push_back(i); } inline int query(int qid,int l,int r,int pos) { if(!qid) return 0; if(l&gt;pos) return sum[qid]; int m=(l+r)&gt;&gt;1; if(m&gt;pos) return query(ris[qid],m+1,r,pos)+query(les[qid],l,m,pos); return query(ris[qid],m+1,r,pos); } inline int merge(int u,int v)//the core { if(!u) return v;//某个没有，就直接用另一个，儿子信息可以直接用，不需要更新 if(!v) return u; int t = ++cnt;//都有，就另建一个点记录合并后的信息 sum[t]=sum[u]+sum[v]; les[t]=merge(les[u],les[v]);//并且维护新节点的儿子信息 ris[t]=merge(ris[u],ris[v]); return t; } inline void modify(int&amp; qid,int l,int r,int pos)//add the current point { if(!qid) qid=++cnt; ++sum[qid]; if(l==r) return; int m=(l+r)&gt;&gt;1; if(m&gt;=pos) modify(les[qid],l,m,pos); else modify(ris[qid],m+1,r,pos); } inline int dfs(int now) { for(int i=0;i&lt;son[now].size();++i) { dfs(son[now][i]); pid[now]=merge(pid[now],pid[son[now][i]]); } ans[now]=query(pid[now],1,n,id[now]); modify(pid[now],1,n,id[now]);//add the current point } int main() { readin(); dfs(1); for(int i=1;i&lt;=n;++i) printf(&quot;%d\\n&quot;,ans[i]); return 0; }","permalink":"http://sher-wu.github.io/2019/12/06/BZOJ4756/","photos":[]},{"tags":[{"name":"组合概率","slug":"组合概率","permalink":"http://sher-wu.github.io/tags/%E7%BB%84%E5%90%88%E6%A6%82%E7%8E%87/"}],"title":"UVA11637","date":"2019/11/28","text":"UVA11637 - Garbage Remembering Exam 题意： 大概意思是，有n个单词，分别打乱放在一个环形的，一个非环形里面，环形的两个单词距离为顺时针逆时针的最小值，非环形的就是位置的差的绝对值，如果有一对单词，在两个里面的距离都是不大于k，那么这单词为无效单词，问平均会出现多少个无效单词 &gt; 思路： 组合概率，假设在非环形形成了一个随机序列，那么我们给它标号1-n,如果我们能分别算出1-n的有效概率，那么就等于算出了无效概率，那么有效概率等于和它距离大于k的那些位置的所有单词拿出来，假设有x个，在环形序列中选一个位置放这个单词，然后它周围的2k的位置（因为是环形序列）要放入这些x个，就是x个选2k个放进去，再全排列，然后剩下n-2k-1个位置再全排列，然后总情况数为n的全排列，所以这样公式一组合起来就是nC(2k,x)2k!(n−2k−1)!/n!，化简一下公式得到x!(n−2k−1)!/(x−2k)!/(n−1)!，这个数值无法直接运算，然后观察能发现他的分子和分母可以合起来考虑变成乘除的项数相同，分子为(n−2k−1)∗(n−2k−2)∗...∗(x−2k+1)，分母为(n−1)∗(n−2)∗...∗(x+1)，那么就可以先递推预处理出一个p数组，p[x]就表示原公式解，那么整个答案为就是非环形序列每个位置的概率*1求出期望，然后累加求总和，最后再用n减去该值得到无效单词的期望。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //转化计算式，变成多个x-i/n-i相乘（x指在非环中当前数在它k范围外数的个数），然后预处理 const int N = 100005; int n, k; double p[N]; void init(int n, int k) { memset(p, 0, sizeof(p)); p[n - 1] = 1.0; for (int i = n - 1; i &gt; 2 * k; i--) { p[i - 1] = p[i] * (i - 2 * k) * 1.0 / (i * 1.0) ; } } double solve(int n, int k) { init(n, k); double ans = 0; for (int i = 1; i &lt;= n; i++) { int x = max(i - k - 1, 0) + max(n - i - k, 0); ans += p[x]; } return n - ans; } int main() { int cas = 0; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; n || k) { printf(&quot;Case %d: %.4lf\\n&quot;, ++cas, solve(n, k)); } return 0; }","permalink":"http://sher-wu.github.io/2019/11/28/UVA11637/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ1070","date":"2019/11/27","text":"BZOJ1070 [SCOI2007] 修车 Description 同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input 第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。 第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。 Output 最小平均等待时间，答案精确到小数点后2位。 Sample Input 2 2 3 2 1 4 Sample Output 1.50 HINT 数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60),(1&lt;=T&lt;=1000) 思路： 对同一个技术人员，如果车i倒数第x个被修理，那么该车对总时间的贡献就是tix。每个技术人员都可以把任何一辆车倒数第1个修，第2个修...第n个修，那么他们对总时间分别有不同的贡献。 因而建图：s到所有车连flow=1,cost=0的边，车向每个技工的倒数第x个位置连flow=1,cost=tix的边，每个技工的每个位置向t连flow=1,cost=0的边。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2020; const int INF = 1e9+7; typedef long long ll; int le,ri,sp[12][70]; struct MCMF{ struct Edge{ int from,to,cap,cost; Edge(){} Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost){} }; int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn];//inqueue int d[maxn];//dis int p[maxn];//pre int a[maxn];//flow void init() { for(int i=0;i&lt;=n;++i) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost) { edges.push_back(Edge(from,to,cap,cost)); edges.push_back(Edge(to,from,0,-cost)); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BF(int&amp; flow,int&amp; cost) { for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0; d[s]=0,inq[s]=1,p[s]=0,a[s]=INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()) { int u=Q.front();Q.pop(); inq[u]=0; //cout&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;G[u].size()&lt;&lt;&#39; &#39;&lt;&lt;d[u]&lt;&lt;&#39;\\n&#39;; for(int i=0;i&lt;G[u].size();++i) { Edge&amp; e=edges[G[u][i]]; if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost) { d[e.to]=d[u]+e.cost; p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap); if(!inq[e.to]) { Q.push(e.to); inq[e.to]=1; } } } } if(d[t]==INF) return false; flow+=a[t]; cost+=d[t]*a[t]; int u=t; while(u!=s) { edges[p[u]].cap-=a[t]; edges[p[u]^1].cap+=a[t]; u=edges[p[u]].from; } return true; } int Mincost() { int flow=0,cost=0; //cout&lt;&lt;m&lt;&lt;endl; while(BF(flow,cost)); //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;p[i]&lt;&lt;endl; return cost; } }NF; inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ //if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x; } inline void readin() { int temp; le=read(),ri=read(); NF.s=0; NF.n=NF.t=ri*(le+1)+1; for(int i=1;i&lt;=ri;++i) NF.AddEdge(0,i,1,0); for(int i=1;i&lt;=ri;++i) for(int j=1;j&lt;=le;++j) { sp[j][i]=read(); for(int k=1;k&lt;=ri;++k) NF.AddEdge(i,j*ri+k,1,k*sp[j][i]); } for(int i=ri+1;i&lt;NF.t;++i) NF.AddEdge(i,NF.t,1,0); } int main() { NF.init(); readin(); printf(&quot;%.2lf&quot;,1.0*NF.Mincost()/ri); return 0; }","permalink":"http://sher-wu.github.io/2019/11/27/BZOJ1070/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ2879","date":"2019/11/26","text":"BZOJ2879 [NOI2012] 美食节 Description CZ市为了欢迎全国各地的同学，特地举办了一场盛大的美食节。作为一个喜欢尝鲜的美食客，小M自然不愿意错过这场盛宴。他很快就尝遍了美食节所有的美食。然而，尝鲜的欲望是难以满足的。尽管所有的菜品都很可口，厨师做菜的速度也很快，小M仍然觉得自己桌上没有已经摆在别人餐桌上的美食是一件无法忍受的事情。于是小M开始研究起了做菜顺序的问题，即安排一个做菜的顺序使得同学们的等待时间最短。小M发现，美食节共有n种不同的菜品。每次点餐，每个同学可以选择其中的一个菜品。总共有m个厨师来制作这些菜品。当所有的同学点餐结束后，菜品的制作任务就会分配给每个厨师。然后每个厨师就会同时开始做菜。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。此外，小M还发现了另一件有意思的事情: 虽然这m个厨师都会制作全部的n种菜品，但对于同一菜品，不同厨师的制作时间未必相同。他将菜品用1, 2, …, n依次编号，厨师用1, 2, …, m依次编号，将第j个厨师制作第i种菜品的时间记为 ti,j 。小M认为：每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。换句话说，如果一个同学点的菜是某个厨师做的第k道菜，则他的等待时间就是这个厨师制作前k道菜的时间之和。而总等待时间为所有同学的等待时间之和。现在，小M找到了所有同学的点菜信息: 有 pi 个同学点了第i种菜品（i=1, 2, …, n）。他想知道的是最小的总等待时间是多少。 Input 输入文件的第1行包含两个正整数n和m，表示菜品的种数和厨师的数量。 第2行包含n个正整数，其中第i个数为pi，表示点第i种菜品的人数。 接下来有n行，每行包含m个非负整数，这n行中的第i行的第j个数为ti,j，表示第j个厨师制作第i种菜品所需的时间。 输入文件中每行相邻的两个数之间均由一个空格隔开，行末均没有多余空格。 Output 输出仅一行包含一个整数，为总等待时间的最小值。 Sample Input 3 2 3 1 1 5 7 3 6 8 9 Sample Output 47 样例说明 厨师1先制作1份菜品2，再制作2份菜品1。点这3道菜的3个同学的等待时间分别为3，3+5=8，3+5+5=13。 厨师2先制作1份菜品1，再制作1份菜品3。点这2道菜的2个同学的等待时间分别为7，7+9=16。 总等待时间为3+8+13+7+16=47。 虽然菜品1和菜品3由厨师1制作更快，如果这些菜品都由厨师1制作，总等待时间反而更长。如果按上述的做法，将1份菜品1和1份菜品3调整到厨师2制作，这样厨师2不会闲着，总等待时间更短。 可以证明，没有更优的点餐方案。 数据规模及约定 对于100%的数据，n &lt;= 40, m &lt;= 100, p &lt;= 800, ti,j &lt;= 1000（其中p = ∑pi，即点菜同学的总人数）。 题意： n种菜m个厨师，第j个厨师做第i个菜要t[i][j]秒，每个菜点了ai份，顾客等待时间为从开始到他这份菜做完的时间，问等待总时间是多少。 思路： 与「BZOJ1070」[SCOI2007]修车类似，只是数据规模增大了。 因而，需要用到动态加点的思想。就是说，在我考虑下一个让谁做哪种的菜的时候，它只会是某一位厨师的倒数的第x道菜，因为如果让他把这道菜放在倒数第x+1道菜来做的话，肯定没有放在倒数第x道菜更优。因而，只有当一位厨师做了倒数第x道菜后（该厨师的倒数第x位置有了流量后），才允许他做倒数第x+1道菜（在菜与该厨师的倒数第x+1位置之间连边）。其他和BZOJ1070相似。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e5+20; const int INF = 1e9+7; typedef long long ll; //建边的时候建错了，以及要避免变量的重名，MCMF中的n，m不是题目给的n，m的意思 //cai是菜数，cook是厨师数，people是顾客数，sp=spend int cai,cook,sp[50][110],people; struct MCMF{ struct Edge{ int from,to,cap,cost; Edge(){} Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost){} }; int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn];//inqueue int d[maxn];//dis int p[maxn];//pre int a[maxn];//flow void init() { for(int i=0;i&lt;=n;++i) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost) { edges.push_back(Edge(from,to,cap,cost)); edges.push_back(Edge(to,from,0,-cost)); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BF(int&amp; flow,int&amp; cost) { for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0; d[s]=0,inq[s]=1,p[s]=0,a[s]=INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()) { int u=Q.front();Q.pop(); inq[u]=0; //cout&lt;&lt;u&lt;&lt;&#39; &#39;&lt;&lt;G[u].size()&lt;&lt;&#39; &#39;&lt;&lt;d[u]&lt;&lt;&#39;\\n&#39;; for(int i=0;i&lt;G[u].size();++i) { Edge&amp; e=edges[G[u][i]]; if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost) { d[e.to]=d[u]+e.cost; p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap); if(!inq[e.to]) { Q.push(e.to); inq[e.to]=1; } } } } if(d[t]==INF) return false; flow+=a[t]; cost+=d[t]*a[t]; int u=t; while(u!=s) { edges[p[u]].cap-=a[t]; edges[p[u]^1].cap+=a[t]; u=edges[p[u]].from; } return true; } int Mincost() { int flow=0,cost=0; //cout&lt;&lt;m&lt;&lt;endl; while(BF(flow,cost)) { int x=edges[p[t]].from,y=(x-cai)/people+1,z=(x-cai)%people; AddEdge(x+1,t,1,0); for(int i=1;i&lt;=cai;++i) AddEdge(i,x+1,1,((z+1)*sp[i][y])); //cout&lt;&lt;edges[p[t]].from&lt;&lt;&#39; &#39;&lt;&lt;flow&lt;&lt;&#39; &#39;&lt;&lt;cost&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl; } //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;p[i]&lt;&lt;endl; return cost; } }NF; inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ //if(ch==&#39;-&#39;) f=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x; } inline void readin() { int temp; cai=read(),cook=read(); for(int i=1;i&lt;=cai;++i) { temp=read(); NF.AddEdge(0,i,temp,0); people+=temp; } NF.s=0; NF.n=NF.t=cai+people*cook+1; for(int i=1;i&lt;=cai;++i) for(int j=1;j&lt;=cook;++j) { sp[i][j]=read(); NF.AddEdge(i,cai+(j-1)*people+1,1,sp[i][j]); } for(int i=1;i&lt;=cook;++i) NF.AddEdge(cai+(i-1)*people+1,NF.t,1,0); } int main() { NF.init(); readin(); cout&lt;&lt;NF.Mincost(); return 0; }","permalink":"http://sher-wu.github.io/2019/11/26/BZOJ2879/","photos":[]},{"tags":[{"name":"权值线段树","slug":"权值线段树","permalink":"http://sher-wu.github.io/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"K小值","slug":"K小值","permalink":"http://sher-wu.github.io/tags/K%E5%B0%8F%E5%80%BC/"}],"title":"HDU6464","date":"2019/11/25","text":"HDU6464 免费送气球 Description 又到了GDUT一年一度的程序设计竞赛校赛的时间啦。同学们只要参加校赛，并且每解出一道题目就可以免费获得由ACM协会和集训队送出的气球一个。听到这个消息，JMC也想参加免费拿气球。可是，由于JMC太菜了而被禁止参赛，于是他找到你想让你帮忙参加比赛，可以通过执行下面的C++程序解决问题后获得气球并送给他。JMC保证了下面的程序一定能获得正确的结果。 void solve(int Q, int type[], long long first[], long long second[]) { vector&lt;long long&gt; vec; for (int i = 0; i &lt; Q; ++i) { if (type[i] == 1) { long long k = first[i], val = second[i]; while (k--) { vec.push_back(val); } } else if (type[i] == 2) { sort(vec.begin(), vec.end()); long long l = first[i] - 1, r = second[i], res = 0; while (l &lt; r) { res = (res + vec[l++]) % 1000000007; } printf(&quot;%lld\\n&quot;, res); } } } 为防止你被JMC的代码搞到头晕目眩，JMC特意给出了问题的文字描述。已知一开始有一个空序列，接下来有Q次操作，每次操作给出type、first和second三个值。当type为1时，意味着该操作属于第一种操作：往序列尾部添加first个second数。当type为2时，意味着该操作属于第二种操作：查询序列中第first小至第second小的数值之和（一共有(second - first + 1)个数被累加），并将结果对1000000007取模后输出。 Input 单组数据 第一行一个Q（1 &lt;= Q &lt;= 1e5），代表Q次操作。 接下来有Q行，每行包含三个整数type、first和second；其中1 &lt;= type &lt;= 2。当type等于1时，0 &lt;= first,second &lt; 1e9。当type等于2时，1 &lt;= first &lt;= second，且first和second均不大于目前已添加进序列的数的数量。 Output 对于每次操作二，将结果对1000000007取模后输出。 Sample Input 6 1 5 1 1 6 3 2 2 5 2 4 8 1 2 2 2 4 8 Sample Output 4 11 9 思路： 可以当成权值线段树的模板的题。关键在于query的处理。 全在左直接算左儿子，全在右要减去左儿子再算右儿子。两边都有要le到左儿子右端点+右儿子左端点到ri. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+10; const int maxm=1e9+7; typedef long long ll; struct func{ int type; ll fir,sec; }q[maxn]; ll a[maxn],t; ll tree[4*maxn],sum[4*maxn]; void pushup(int now) { tree[now]=tree[now&lt;&lt;1]+tree[now&lt;&lt;1|1]; sum[now]=(sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1])%maxm; } void insert(int now,int pos,int le,int ri,int num) { if(le==ri) { tree[now]+=num; sum[now]=tree[now]%maxm*a[le]%maxm; return; } int mid=(le+ri)&gt;&gt;1; if(pos&lt;=mid) insert(now&lt;&lt;1,pos,le,mid,num); else insert(now&lt;&lt;1|1,pos,mid+1,ri,num); pushup(now); } ll query(int now,int le,int ri,ll fir,ll sec)//WA了两发的地方。没注意到fir和sec可以爆int { ll sums=0; if(fir==1&amp;&amp;tree[now]==sec) return sum[now]%maxm; if(le==ri) return (sec-fir+1)%maxm*a[le]%maxm; int mid=(le+ri)&gt;&gt;1; if(sec&lt;=tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1,le,mid,fir,sec)%maxm;//关键步骤！！！ else if(fir&gt;tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1|1,mid+1,ri,fir-tree[now&lt;&lt;1],sec-tree[now&lt;&lt;1])%maxm; else { sums=(query(now&lt;&lt;1,le,mid,fir,tree[now&lt;&lt;1])+query(now&lt;&lt;1|1,mid+1,ri,1,sec-tree[now&lt;&lt;1]))%maxm; } return sums; } void run() { int Q; cin&gt;&gt;Q; for(int i=1;i&lt;=Q;i++) { scanf(&quot;%d%lld%lld&quot;,&amp;q[i].type,&amp;q[i].fir,&amp;q[i].sec); if(q[i].type==1) a[++t]=q[i].sec; } sort(a+1,a+t+1); t=unique(a+1,a+t+1)-(a+1);//WA了一发的地方。权值线段树必须要排序后去重。unique返回值的意思是剩余长度 for(int i=1;i&lt;=Q;i++) { if(q[i].type==1) { insert(1,lower_bound(a+1,a+t+1,q[i].sec)-a,1,t,q[i].fir); } else { cout&lt;&lt;query(1,1,t,q[i].fir,q[i].sec)&lt;&lt;endl; } } } int main() { run(); return 0; }","permalink":"http://sher-wu.github.io/2019/11/25/HDU6464/","photos":[]},{"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计数排序","slug":"计数排序","permalink":"http://sher-wu.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}],"title":"CF558E","date":"2019/11/24","text":"CF558E A Simple Task 5 seconds per test This task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non-decreasing order if k = 1 or in non-increasing order if k = 0. Output the final string after applying the queries. Input The first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters. Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, ). Output Output one line, the string S after applying the queries. Examples input 10 5 abacdabcda 7 10 0 5 8 1 1 4 0 3 6 0 7 10 1 output cbcaaaabdd input 10 1 agjucbvdfk 1 10 1 output abcdfgjkuv Note First sample test explanation: 题意：给你一串字符串，每次操作对一段区间内的字符串作升序或降序排序。输出所有操作后的字符串。 &gt;错误思路：把az依次赋以126的值，然后做区间的修改。。。写到一半就暴毙了 思路： 这是直接听归神例会讲的方法。为a~z各建立一棵线段树，然后把字符放入它自己的线段树中。每次区间排序的时候，区间求该字符的个数，区间清空，然后接着之前的顺序赋值。 比如ababa，变为升序时，t=1，1（1+3-1）变为a，然后t变为4，4（4+2-1）变为b. 复杂度O（m*26logn） #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+10; int tree[30][4*maxn],lazy[30][4*maxn]; int n,m; char c; //lazy -1 未使用, 0或1 区间赋值为0或1 void pushup(int trnum,int now) { tree[trnum][now]=tree[trnum][now&lt;&lt;1]+tree[trnum][now&lt;&lt;1|1]; } void pushdown(int trnum,int num,int l,int mid,int r) { if(lazy[trnum][num]==0) { tree[trnum][num&lt;&lt;1]=tree[trnum][num&lt;&lt;1|1]=lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=0; lazy[trnum][num]=-1; } else if(lazy[trnum][num]==1) { tree[trnum][num&lt;&lt;1]=mid-l+1; tree[trnum][num&lt;&lt;1|1]=r-mid; lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=1; lazy[trnum][num]=-1; } } void addline(int trnum,int num,int le,int ri,int l,int r) { if(l&gt;=le&amp;&amp;r&lt;=ri) { tree[trnum][num]=r-l+1; lazy[trnum][num]=1; return; } int mid=(l+r)&gt;&gt;1; pushdown(trnum,num,l,mid,r); if(mid&gt;=le) addline(trnum,num&lt;&lt;1,le,ri,l,mid); if(mid&lt;ri) addline(trnum,num&lt;&lt;1|1,le,ri,mid+1,r); pushup(trnum,num); } void add(int num,int pos,int trnum,int l,int r) { if(l==r) { tree[trnum][num]=1; return; } int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(num&lt;&lt;1,pos,trnum,l,mid); else add(num&lt;&lt;1|1,pos,trnum,mid+1,r); pushup(trnum,num); }//其实add可以和addline合并但是当时没想到这么多就先写了个单点的 int counts(int trnum,int num,int le,int ri,int l,int r) { if(l&gt;=le&amp;&amp;r&lt;=ri) { lazy[trnum][num]=0; int t=tree[trnum][num]; tree[trnum][num]=0; return t; } int mid=(l+r)&gt;&gt;1,sum=0; pushdown(trnum,num,l,mid,r); if(mid&gt;=le) sum+=counts(trnum,num&lt;&lt;1,le,ri,l,mid); if(mid&lt;ri) sum+=counts(trnum,num&lt;&lt;1|1,le,ri,mid+1,r); pushup(trnum,num); return sum; } void run() { cin&gt;&gt;n&gt;&gt;m; c=getchar(); for(int i=1;i&lt;=n;i++) { c=getchar(); add(1,i,c-&#39;a&#39;,1,n); } while(m--) { int le,ri,t,xu,totnum; scanf(&quot;%d%d%d&quot;,&amp;le,&amp;ri,&amp;xu); if(xu) { t=le; for(int i=0;i&lt;26;i++) { totnum=counts(i,1,le,ri,1,n); //cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;totnum&lt;&lt;endl; if(totnum) { addline(i,1,t,t+totnum-1,1,n); t+=totnum; } } } else { t=ri; for(int i=0;i&lt;26;i++) { totnum=counts(i,1,le,ri,1,n); //cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;totnum&lt;&lt;endl; if(totnum) { addline(i,1,t-totnum+1,t,1,n); t-=totnum; } } } } for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;26;j++) { if(counts(j,1,i,i,1,n)) { printf(&quot;%c&quot;,&#39;a&#39;+j); break; } //cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;j&lt;&lt;endl; } } } void init() { memset(lazy,-1,sizeof(lazy)); } int main() { if(fopen(&quot;test.txt&quot;,&quot;r&quot;)!=NULL) freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin); init(); run(); return 0; }","permalink":"http://sher-wu.github.io/2019/11/24/CF558E/","photos":[]},{"tags":[{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"位运算","slug":"位运算","permalink":"http://sher-wu.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"title":"CF1174D","date":"2019/11/23","text":"CF1174D Ehab and the Expected XOR Problem Description Given two integers n and x, construct an array that satisfies the following conditions: for any element ai in the array, \\(1&lt;=ai&lt;2n\\); there is no non-empty subsegment with bitwise XOR equal to 0 or x, its length l should be maximized. A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Input The only line contains two integers n and x (1≤n≤18, 1≤x&lt;218). Output The first line should contain the length of the array l. If l is positive, the second line should contain l space-separated integers a1, a2, …, al (1≤ai&lt;2n) — the elements of the array a. If there are multiple solutions, print any of them. Examples input 3 5 output 3 6 1 3 input 2 4 output 3 1 3 1 input 1 1 output 0 Note In the first example, the bitwise XOR of the subsegments are {6,7,4,1,2,3}. 题意： 构造一个数列，元素为1~2^n的数，使得数列的任意子段的XOR和均不等于0与X。求数列的长度和任意一个解。 思路： 最重要的：想到取构造前缀XOR和数组，而非直接去构造数组ai。 具体的：构造前缀XOR和数组bi，则alal+1···ar=bl-1br.则不等于0-&gt;任意的bi与bj不相等。不等于X-&gt;若bi^bj=X，则只能取其一（代码中取了更小的）。遍历一遍所有数即可。然后用前缀数组算出原数组。 时间复杂度O（2^n） #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 3e6+10; int n,x,t[maxn],num,f[20],cou[maxn];//cou为输出，t[i]=1表示数组b不能选i，实际上用一个即可 int main() { cin&gt;&gt;n&gt;&gt;x; t[0]=t[x]=1; for(int i=1;i&lt;(ll)(pow(2,n));i++) if(t[i]==0) cou[++num]=i,t[x^i]=1;//i^j=x &lt;==&gt; i^x=j ,让之后选的数不为i^x或x就行 cout&lt;&lt;num&lt;&lt;endl; if(num!=0) cout&lt;&lt;cou[1]&lt;&lt;&#39; &#39;; for(int i=1;i&lt;num;i++) cout&lt;&lt;(cou[i]^cou[i+1])&lt;&lt;&#39; &#39;; return 0; }","permalink":"http://sher-wu.github.io/2019/11/23/CF1174D/","photos":[]},{"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sher-wu.github.io/tags/DFS/"},{"name":"分治","slug":"分治","permalink":"http://sher-wu.github.io/tags/%E5%88%86%E6%B2%BB/"}],"title":"GYM101915K","date":"2019/11/18","text":"GYM101915K Chess Positions Description 一串01串，将其分成多个（可以为1）个区间，分别求和，要求所得的串是回文的。求总的种类数，结果对1e9+7取模 Input The first line contains a single integer T denoting the number of test cases. Each test case consists of one line which contains the original sequence of zeros and ones. The length of every sequence is less than or equal to 50. Output For each test print one line containing one integer, the number of different ways to divide the original sequence leading to a sumindrome sequence modulo (1e9+7). Sample Input 2 0110 1001 Sample Output 4 8 Note The ways of dividing the sequence in the second sample are: -&gt; 2 (1)(001) -&gt; 1, 1 (100)(1) -&gt; 1, 1 (10)(01) -&gt; 1, 1 (1)(00)(1) -&gt; 1, 0, 1 (1)(0)(01) -&gt; 1, 0, 1 (10)(0)(1) -&gt; 1, 0, 1 (1)(0)(0)(1) -&gt; 1, 0, 0, 1 思路： 回文数的要求就是从左和从右一样，那么从左开始和从右开始的总值一样时，就把这些值合并，再求剩下里面的回文的种类数。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll maxn=1e9+7; char a[60]; int dp[60][60]; void init() { memset(dp,-1,sizeof(dp)); } ll dfs(int l,int r) { //cout&lt;&lt;l&lt;&lt;&#39; &#39;&lt;&lt;r&lt;&lt;&#39;\\n&#39;; if(l&gt;=r) return dp[l][r]=1; if(dp[l][r]!=-1) return dp[l][r]; int &amp;tent=dp[l][r]=1;//这一块全部加起来作为中间项必定正确 int suml=0; for(int i=l;i&lt;r;i++) { suml+=a[i]-&#39;0&#39;; int sumr=0; for(int j=r;j&gt;i;j--) { sumr+=a[j]-&#39;0&#39;; if(suml&lt;sumr) break; if(suml==sumr) tent=(tent+dfs(i+1,j-1))%maxn; } } return tent; } int main() { //freopen(&quot;text.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--) { init(); scanf(&quot;%s&quot;,a); printf(&quot;%lld\\n&quot;,dfs(0,strlen(a)-1)); } }","permalink":"http://sher-wu.github.io/2019/11/18/GYM101915K/","photos":[]},{"tags":[{"name":"离散化","slug":"离散化","permalink":"http://sher-wu.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"搜索","permalink":"http://sher-wu.github.io/tags/%E6%90%9C%E7%B4%A2/"}],"title":"CF1119D","date":"2019/11/17","text":"CF1119D Frets On Fire Description Miyako came to the flea kingdom with a ukulele. She became good friends with local flea residents and played beautiful music for them every day. In return, the fleas made a bigger ukulele for her: it has n strings, and each string has (1018+1) frets numerated from 0 to 1018. The fleas use the array s1,s2,…,sn to describe the ukulele's tuning, that is, the pitch of the j-th fret on the i-th string is the integer si+j. Miyako is about to leave the kingdom, but the fleas hope that Miyako will answer some last questions for them. Each question is in the form of: \"How many different pitches are there, if we consider frets between l and r (inclusive) on all strings?\" Miyako is about to visit the cricket kingdom and has no time to answer all the questions. Please help her with this task! Formally, you are given a matrix with n rows and (1018+1) columns, where the cell in the i-th row and j-th column (0≤j≤1018) contains the integer si+j. You are to answer q queries, in the k-th query you have to answer the number of distinct integers in the matrix from the lk-th to the rk-th columns, inclusive. Input The first line contains an integer n (1≤n≤100000) — the number of strings. The second line contains n integers s1,s2,…,sn (0≤si≤1018) — the tuning of the ukulele. The third line contains an integer q (1≤q≤100000) — the number of questions. The k-th among the following q lines contains two integers lk，rk (0≤lk≤rk≤1018) — a question from the fleas. Output Output one number for each question, separated by spaces — the number of different pitches. Examples input 6 3 1 4 1 5 9 3 7 7 0 2 8 17 output 5 10 18 input 2 1 500000000000000000 2 1000000000000000000 1000000000000000000 0 1000000000000000000 output 2 1500000000000000000 题意： 有n个以ai开头，依次+1的数列，问在每个数列中去li~ri项，总共有多少不相同的项 思路： li与ri怎么取并没有意义，只有长度才有意义。 排序后求差，当长度-1&gt;=两相邻数之差时,小的数将没有贡献。 Ⅰ 用离散化的方法，对差排序后对其进行叠加及保存(dxr用的&lt;1&gt;，且省去了离散化） Ⅱ &lt;1&gt; c[i] = b[i] + c[i-1] (b是差的排序数组） 前后两数之差大于len的，都有贡献，小于len的全体，有c[i]的贡献 Ⅱ &lt;2&gt; ans[num[i]]=ans[num[i-1]]+tot(num[i]-num[i-1]) (tot当前仍有贡献的数的个数)，用rec[i]来保存) out[k]=ans[num[pos]]+(res[num[pos]])*(len-num[pos]) 所求 = num[i]的总贡献+(len-num[i])间有效数个数长度 DXR &lt;1&gt; : //总的来说，就是差大于len的，都有贡献，小于len的全体，有c[i]的贡献 //有一个极大的好处，就是没有用到离散化的知识点 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; typedef unsigned long long ull; const int NN = 110000; int n, num; ull b[NN], c[NN], tmp, h, len, l, r, ans, m, a[NN]; bool cmp(ull a, ull b) { return a &lt; b; } int main() { //freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%llu&quot;, &amp;a[i]); } //首先对a排序 sort(a + 1, a + n + 1, cmp); num = 0; for (int i = 2; i &lt;= n; i++) if (a[i] - a[i - 1]) b[++num] = a[i] - a[i - 1]; //求两个大小相邻的，不同的数字之间（去重）的差 sort(b + 1, b + num + 1, cmp); //对差排序，求部分和（因为差&lt;len的所有点都有部分重复，需要减去） c[0] = 0; for (int i = 1; i &lt;= num; i++) c[i] = b[i] + c[i - 1]; //len到b[i]时，该数与该数-1有b[i]未重合 //c[i]表示到第i个数时，如果len&gt;=b[i]，前面所有数的获得的有效数的总数 /* for (int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\\n&quot;); for (int i=1; i&lt;=num; i++) printf(&quot;%d &quot;, b[i]); printf(&quot;\\n&quot;); for (int i=1; i&lt;=num; i++) printf(&quot;%d &quot;, c[i]); printf(&quot;\\n&quot;); */ scanf(&quot;%d&quot;, &amp;m); while (m--) { scanf(&quot;%llu%llu&quot;, &amp;l, &amp;r); len = r - l + 1; //由题目，最终答案与起点终点无关，至于起点与终点之间的距离有关 //由题, 每个点与上一个点重复的个数=len-它与上一个点的差（若差&gt;=len, 则无重复点） //num是差的个数，有效数的总数为num+1 ans = (num + 1) * len; //先将每个数字可以引出的新数都算上（很可能中间有重复的） tmp = lower_bound(b + 1, b + num + 1, len) - b; //找到比len小的最大的差，即为（tmp-1）， ans -= len * (tmp - 1) - c[tmp - 1]; //减去重复的个数（每个点仅考虑与上一个点重复的） //假设所有&lt;len的数都产生了重复，全部删去，再补上实际上未产生重复的 //printf(&quot;\\n%llu\\n&quot;, tmp); printf(&quot;%llu &quot;, ans); } return 0; } MS &lt;1&gt; : //离线完成，极大的降低了复杂度 #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; typedef long long ll; typedef pair&lt;ll, ll&gt; P; typedef pair&lt;P, int&gt; PP; const int maxn = 1e5 + 100; ll a[maxn], b[maxn]; P ans[maxn]; PP q[maxn]; bool cmp(PP p1, PP p2) { if (p1.first.second - p1.first.first &lt; p2.first.second - p2.first.first) return 1; else return 0; } bool cmp1(PP p1, PP p2) { if (p1.second &lt; p2.second) return 1; else return 0; } int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0; i &lt; n - 1; i++) b[i] = (a[i + 1] - a[i]); sort(b, b + n - 1); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) { cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second; q[i].second = i; } sort(q, q + t, cmp); ll now = 0, coun = 0; for (int i = 0; i &lt; t; i++) { ll cha = q[i].first.second - q[i].first.first + 1; while (coun != n - 1 &amp;&amp; cha &gt;= b[coun]) { now += b[coun]; coun++; } ans[i].first = q[i].second; ans[i].second = now + cha * (n - coun); } sort(ans, ans + t); for (int i = 0; i &lt; t; i++) { cout &lt;&lt; ans[i].second &lt;&lt; &quot; &quot;; } } YZM &lt;2&gt; : #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e5 + 10; typedef long long ll; int n, q, tot; ll s[maxn]; ll l, r, len; map&lt;ll, ll&gt; vis, res, ans; ll num[maxn], cnt; ll out[maxn]; int main() { cin &gt;&gt; n; tot = n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;s[i]); sort(s + 1, s + n + 1); for (int i = 1; i &lt; n; ++i) { ll p = s[i + 1] - s[i]; if (!p) tot--; else if (!vis[p]) num[++cnt] = p; //用num保存所有的数 vis[p]++; } //for(map&lt;ll,ll&gt;::iterator it=vis.begin();it!=vis.end();it++) //printf(&quot;%I64d:%I64d\\n&quot;,it-&gt;first,it-&gt;second); sort(num + 1, num + cnt + 1); ans[0] = num[0] = 0; for (int i = 1; i &lt;= cnt; ++i) { ans[num[i]] = ans[num[i - 1]] + tot * (num[i] - num[i - 1]); //到num[i]这个数为止，所有数的贡献=上一段的贡献+num[i-1]+1到num[i]间有效数的贡献 //cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;ans[num[i]]&lt;&lt;endl; res[num[i - 1]] = tot; tot -= vis[num[i]]; //tot为下一段中仍有贡献的数的个数 } res[num[cnt]] = tot; //for(int i=0;i&lt;=cnt;++i) //printf(&quot;-&gt;%I64d:%I64d + %I64d\\n&quot;,num[i],ans[num[i]],res[num[i]]); scanf(&quot;%d&quot;, &amp;q); for (int k = 1; k &lt;= q; ++k) { scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r); len = r - l + 1; int pos = upper_bound(num, num + cnt + 1, len) - num; pos--; //num[pos]&lt;=len //cout&lt;&lt;pos&lt;&lt;endl; //printf(&quot;pos:%d\\n&quot;,pos); //printf(&quot;v:%I64d +:%I64d\\n&quot;,ans[num[pos]],res[num[pos]]); out[k] = ans[num[pos]] + (res[num[pos]]) * (len - num[pos]); } for (int k = 1; k &lt;= q; ++k) printf(&quot;%lld &quot;, out[k]); return 0; }","permalink":"http://sher-wu.github.io/2019/11/17/CF1119D/","photos":[]},{"tags":[{"name":"DP","slug":"DP","permalink":"http://sher-wu.github.io/tags/DP/"}],"title":"PTA-L3-20","date":"2019/11/15","text":"PTA-L3-20 至多删三个字符 Description 给定一个全部由小写英文字母组成的字符串，允许你至多删掉其中3个字符，结果可能有多少种不同的字符串？ Input 输入在一行中给出全部由小写英文字母组成的、长度在区间 [4, 1e6​​] 内的字符串。 Output 在一行中输出至多删掉其中 3 个字符后不同字符串的个数。 Sample Input ababcc Sample Output 25 Hint 删掉 0 个字符得到 &quot;ababcc&quot;。 删掉 1 个字符得到 &quot;babcc&quot;, &quot;aabcc&quot;, &quot;abbcc&quot;, &quot;abacc&quot; 和 &quot;ababc&quot;。 删掉 2 个字符得到 &quot;abcc&quot;, &quot;bbcc&quot;, &quot;bacc&quot;, &quot;babc&quot;, &quot;aacc&quot;, &quot;aabc&quot;, &quot;abbc&quot;, &quot;abac&quot; 和 &quot;abab&quot;。 删掉 3 个字符得到 &quot;abc&quot;, &quot;bcc&quot;, &quot;acc&quot;, &quot;bbc&quot;, &quot;bac&quot;, &quot;bab&quot;, &quot;aac&quot;, &quot;aab&quot;, &quot;abb&quot; 和 &quot;aba&quot;。 思路： 为了避免重复，以及枚举或者组合数在此用起来不现实，因而使用DP。 d[i][j]表示前i个字符中删除j个字符后得到的不同字符串的个数。则 d[i][j+1]+=d[i-1][j]（删除第i个字符）&amp;&amp; d[i][j]+=d[i-1][j]（不删除第i个字符） 如果只是这样转移肯定会有重复的。例如一个字符串cdabnaxy，你删除abn和删除bna后得到的字符串都是cdaxy。 这时候就要去重了，根据上面那个栗子可以发现对于一个字符s[i]，如果在i之前存在一个x使得s[x]==s[i]，那么删除[x,i-1]间的字符和删除[x+1,i]间的字符其实是重复的，等价的，那么d[i][j]就要减去d[x-1][j-(i-x)]，减去删除这段造成的重复串。 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAX = 1e6 + 5; typedef long long ll; char s[MAX]; ll d[MAX][4]; int main() { scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); d[0][0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= 3; j++) { if (d[i - 1][j] == 0) continue; if (j &lt; 3) d[i][j + 1] += d[i - 1][j]; d[i][j] += d[i - 1][j]; for (int k = i - 1; k &gt;= 1 &amp;&amp; i - k &lt;= j; k--) //往前找到第一个k使得s[k]=s[i] { if (s[k] == s[i]) { d[i][j] -= d[k - 1][j - (i - k)]; break; } } } } printf(&quot;%lld\\n&quot;, d[n][0] + d[n][1] + d[n][2] + d[n][3]); return 0; }","permalink":"http://sher-wu.github.io/2019/11/15/PTA-L3-20/","photos":[]},{"tags":[{"name":"贪心","slug":"贪心","permalink":"http://sher-wu.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"}],"title":"CF1041E","date":"2019/11/14","text":"CF Round #509 (Div.2) E. Tree Reconstruction Description 1 second per test Monocarp has drawn a tree (an undirected connected acyclic graph) and then has given each vertex an index. All indices are distinct numbers from 1 to n. For every edge e of this tree, Monocarp has written two numbers: the maximum indices of the vertices of the two components formed if the edge e (and only this edge) is erased from the tree. Monocarp has given you a list of n−1 pairs of numbers. He wants you to provide an example of a tree that will produce the said list if this tree exists. If such tree does not exist, say so. Input The first line contains one integer n (2≤n≤1000) — the number of vertices in the tree. Each of the next n−1 lines contains two integers ai and bi each (\\(1&lt;=ai&lt;bi&lt;=n\\)) — the maximal indices of vertices in the components formed if the i-th edge is removed. Output If there is no such tree that can produce the given list of pairs, print \"NO\" (without quotes). Otherwise print \"YES\" (without quotes) in the first line and the edges of the tree in the next n−1 lines. Each of the last n−1 lines should contain two integers xi and yi (1≤xi,yi≤n) — vertices connected by an edge. Note: The numeration of edges doesn't matter for this task. Your solution will be considered correct if your tree produces the same pairs as given in the input file (possibly reordered). That means that you can print the edges of the tree you reconstructed in any order. Examples input 4 3 4 1 4 3 4 output YES 1 3 3 2 2 4 input 3 1 3 1 3 output NO input 3 1 2 2 3 output NO Note Possible tree from the first example. Dotted lines show edges you need to remove to get appropriate pairs. Example 题意： 是说，要构建一个树，使得它砍掉每一条边时，左右的最大权值是给定的值。 例如样例1，4-2-3-1，砍第一二条边左右最大都是4&amp;3，砍第三条是4&amp;1，符合题意，然后输出每一条边的左右节点。 思路： 最最最基本的，它的某一边最大一定是n，否则直接No。 如果n，x只出现了一次，那直接n，x相连即可。 如果出现了两次，那么要在n与x中间加一个比x小的数i。 如果三次。。。 那么就直接是贪心，从最小的x开始，i也从1开始递增，根据n，x出现的次数多少决定在n，x中间加多少个数（次数-1）。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,a[1010],b[1010],c[1010],now,add[1010],nown=1; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;n;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==n) a[y]++;//（x,n）中x的出现次数 else if(y==n) a[x]++; else { cout&lt;&lt;&quot;NO&quot;; return 0; } } int ch=1; for(int i=1;i&lt;n;i++) { if(a[i])//没有就跳过 { int t=n; while(a[i]&gt;1&amp;&amp;nown&lt;=i)//是1，直接建边 { if(add[nown]==0){ b[++now]=t; c[now]=nown; add[nown]=1; t=nown; a[i]--; } nown++; } if(nown&gt;i)//不是1，先往小的连，到1以后，再建边 { ch=0; break; } b[++now]=t; c[now]=i; add[i]=1; a[i]--; } } if(ch==0)//（x,n）的次数少于剩余的小于x的数的总数了，No { cout&lt;&lt;&quot;NO&quot;; } else { cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(int i=1;i&lt;n;i++) { cout&lt;&lt;b[i]&lt;&lt;&#39; &#39;&lt;&lt;c[i]&lt;&lt;endl; } } return 0; }","permalink":"http://sher-wu.github.io/2019/11/14/CF1041E/","photos":[]},{"tags":[{"name":"模拟","slug":"模拟","permalink":"http://sher-wu.github.io/tags/%E6%A8%A1%E6%8B%9F/"}],"title":"PTA-L1-64","date":"2019/11/13","text":"PTA-L1-64 估值一亿的AI核心代码 Description 本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是： 无论用户说什么，首先把对方说的话在一行中原样打印出来； 消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉； 把原文中所有大写英文字母变成小写，除了 I； 把原文中所有独立的 can you、could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词； 把原文中所有独立的 I 和 me 换成 you； 把原文中所有的问号 ? 换成惊叹号 !； 在一行中输出替换后的句子作为 AI 的回答。 Input 输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。 Output 按题面要求输出，每个 AI 的回答前要加上 AI: 和一个空格。 输入样例： 6 Hello ? Good to chat with you can you speak Chinese? Really? Could you show me 5 What Is this prime? I,don &#39;t know 输出样例： Hello ? AI: hello! Good to chat with you AI: good to chat with you can you speak Chinese? AI: I can speak chinese! Really? AI: really! Could you show me 5 AI: I could show you 5 What Is this prime? I,don &#39;t know AI: what Is this prime! you,don&#39;t know 第一次出去比赛，rating拿了全组第一还是挺开心的。 代码就懒得再写一遍了。讲白了就是一道码农模拟题，难点也主要就在特判怎么设。 &gt; 1、从头开始检测空格，检测的连续的两个空格就连删直到只剩一个（用了char的strcpy，string的erase应该也行） 2、删头尾的空格，与字符前面的空格 3、变换所有大写字母与？-&gt;! 4、开始输出 { Ⅰ 输出个 ’AI: ‘ Ⅱ 一位一位输出直到 a[i]==’\\0' Ⅲ 用连续的字符特判判定 “can you”&amp;&amp;“could you”，并使I+=7,i+=9; Ⅳ 判定I&amp;&amp;me前后是不是字符(是否独立） *A:65 a:97 0:48 Ⅴ 输出’‘ }","permalink":"http://sher-wu.github.io/2019/11/13/PTA-L1-64/","photos":[]},{"tags":[{"name":"Introduct","slug":"Introduct","permalink":"http://sher-wu.github.io/tags/Introduct/"}],"title":"Hello World","date":"2019/11/11","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","permalink":"http://sher-wu.github.io/2019/11/11/Hello%20World/","photos":[]}]}