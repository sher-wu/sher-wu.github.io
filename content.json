{"meta":{"title":"Welcome to sher-wu's home !","subtitle":"","description":"","author":"sher-wu","url":"http://sher-wu.github.io","root":"/"},"posts":[{"tags":[],"title":"Donot Forget!","date":"2099/12/31","text":"Donot Forget! 费用流 KM 树套树 trie树 bitset 徐州现场赛 J 徐州现场赛 单点修改+mex P4147 玉蟾宫 (单调栈) CF 1264C CF 1264E 带权 &amp; 种类 并查集 树链剖分 HDU4747 线段树 冲鸭！","permalink":"http://sher-wu.github.io/2099/12/31/Donot%20Forget!/","photos":[]},{"tags":[{"name":"树上差分","slug":"树上差分","permalink":"http://sher-wu.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}],"title":"P3128","date":"2019/12/10","text":"P3128 [USACO15DEC] 最大流 DescriptionFarmer John给他的牛棚的$N(2\\leq N\\leq50,000)$个隔间之间安装了$N-1$根管道，隔间编号从$1$到$N$。所有隔间都被管道连通了。 FJ有$K(1\\leq K\\leq100,000)$条运输牛奶的路线，第i条路线从隔间si运输到隔间$t_i$。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 InputThe first line of the input contains N and K.The next N-1 lines each contain two integers x and y ($x \\neq y$) describing a pipe between stalls x and y.The next K lines each contain two integers s and t describing the endpoint stalls of a path through which milk is being pumped. OutputAn integer specifying the maximum amount of milk pumped through any stall in the barn. Sample Input15 1023 431 544 255 465 475 483 594 3104 3111 3123 5135 4141 5153 4 Sample Output19 思路：&emsp;&emsp;N个节点构成了一棵树，然后在树上的边有流量，给定一条路线，其所经过的边流量都+1.&emsp;&emsp;典型的含边权的树上差分。根据树上差分思想，把边的流量保存在儿子节点上，当从u到v有一条路线时，只跟u到v上所有的边有关系，而跟lca(u,v)到根的边全都无关。因而flow[u]++,flow[v]++,flow[lca(u,v)]-=2.&emsp;&emsp;全部加完后，用一次DFS即可。 1#include&lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4const int maxn = 5e4+20;5int n,k;6int bei[22],f[maxn],high,tot[maxn];//flow7int d[maxn],fir[maxn],nex[2*maxn],to[2*maxn];8int fa[maxn][22];910inline ll read()&#123;11 ll x=0,f=1;12 char ch=getchar();13 while(ch&lt;'0'||ch&gt;'9')&#123;14 if(ch=='-') f=-1;15 ch=getchar();16 &#125;17 while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;18 x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);19 ch=getchar();20 &#125;21 return x;22&#125;2324inline void dfs1(int now,int pre,int depth)//init for lca25&#123;26 d[now]=depth;27 fa[now][0]=pre;28 for(int i=1;i&lt;=20;++i)29 fa[now][i]=fa[fa[now][i-1]][i-1];30 for(int i=fir[now];i;i=nex[i])31 &#123;32 if(to[i]==pre) continue;33 dfs1(to[i],now,depth+1);34 &#125;35&#125;3637inline int lca(int x,int y)38&#123;39 if(d[x]&lt;d[y]) swap(x,y);40 for(int i=20;i&gt;=0;--i) if(d[x]-bei[i]&gt;=d[y])41 x=fa[x][i];42 if(x==y) return x;43 for(int i=20;i&gt;=0;--i) if(fa[x][i]!=fa[y][i])44 x=fa[x][i],y=fa[y][i];45 return fa[x][0]; 46&#125;4748inline void dfs2(int x,int y)//add values49&#123;50 int l=lca(x,y);51 ++f[x],++f[y],--f[l],--f[fa[l][0]]; 52&#125;5354inline void dfs3(int now,int pre)//find the point with highest value55&#123;56 for(int p=fir[now];p;p=nex[p])57 &#123;58 if(to[p]==pre) continue;59 dfs3(to[p],now);60 tot[now]+=tot[to[p]];61 &#125;62 tot[now]+=f[now];63 if(tot[now]&gt;high) high=tot[now];64&#125;6566int main()67&#123;68 n=read(),k=read();69 bei[0]=1;70 for(int i=1;i&lt;=20;++i) bei[i]=bei[i-1]*2;71 for(int i=1;i&lt;n;++i)72 &#123;73 int p=read(),q=read();74 nex[i]=fir[p],fir[p]=i,to[i]=q;75 nex[n+i]=fir[q],fir[q]=n+i,to[n+i]=p;76 &#125;77 dfs1(1,0,1);78 while(k--) 79 dfs2(read(),read());80 dfs3(1,0);81 printf(\"%d\\n\",high);82 return 0;83&#125;","permalink":"http://sher-wu.github.io/2019/12/10/P3128/","photos":[]},{"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"http://sher-wu.github.io/tags/%E6%A0%88/"}],"title":"BZOJ4756","date":"2019/12/06","text":"BZOJ4756 [Usaco2017 Jan] Promotion Counting Descriptionn只奶牛构成了一个树形的公司，每个奶牛有一个能力值pi，1号奶牛为树根。问对于每个奶牛来说，它的子树中有几个能力值比它大的。 Inputn，表示有几只奶牛 n&lt;=100000接下来n行为1-n号奶牛的能力值pi接下来n-1行为2-n号奶牛的经理（树中的父亲） Output共n行，每行输出奶牛i的下属中有几个能力值比i大 Sample Input1528042893843846930887468169277857146369166957747794718192103 Sample Output1220314050 Solution 如果每个节点都给一个线段树，然后暴力的在父节点将两个线段树合并，那么空间肯定是不够的。因而首先要在空间上进行优化。这里引入了树上的线段树合并。“树上”还是原来的，DFS的顺序从下往上维护。“线段树合并”的步骤如下（这里的线段树实际上是一个链）：对于两颗树的节点u和v&emsp;&emsp;①如果u为空，返回v&emsp;&emsp;②如果v为空，返回u&emsp;&emsp;③否则，新建节点t，整合u和v的信息，然后递归合并u和v的左右子树 1inline int merge(int u,int v)2&#123;3 if(!u) return v;4 if(!v) return u;5 int t = ++cnt;6 sum[t]=sum[u]+sum[v];7 les[t]=merge(les[u],les[v]);8 ris[t]=merge(ris[u],ris[v]);9 return t;10&#125; 思考可知，每有一个位置权值同样存在，就要$O(logn)$的复杂度。那么合并的复杂度取决于两棵线段树重合部分的大小。由于权值线段树中被更新的位置通常很均匀分布，所以合并的两棵线段树通常具有很小的相似性。线段树合并的空间复杂度和时间复杂度都是$O(nlogn)$的。（点大概要开$2nlogn$个，测了一下$n=131072$‬的时候$32n$，$n=524288$的时候$36n$‬，那么$2e7$个应该是肯定够的） 后来看了网上的博客，发现其实这题有更简单的做法。。。按DFS序把所有点放入并取出一个栈，放入时计算小于$a_i$的数量并把$a_i$放入线段树中，取出时再计算一次小于$a_i$的数量，那么两者之差就是答案。 1#include&lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4const int maxn = 2e5+20;5const int maxm = 2e7+20;6int n,id[maxn],a[maxn],b[maxn],fa[maxn],ans[maxn];7int cnt,pid[maxn],sum[maxm],les[maxm],ris[maxm];8vector&lt;int&gt; son[maxn];9inline ll read()&#123;10 ll x=0,f=1;11 char ch=getchar();12 while(ch&lt;'0'||ch&gt;'9')&#123;13 if(ch=='-') f=-1;14 ch=getchar();15 &#125;16 while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;17 x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);18 ch=getchar();19 &#125;20 return x*f;21&#125;2223inline void readin()24&#123;25 n=read();26 for(int i=1;i&lt;=n;++i) a[i]=read(),b[i]=a[i];27 sort(b+1,b+1+n);//题目给定了能力值互异，故不用去重 28 for(int i=1;i&lt;=n;++i) id[i]=lower_bound(b+1,b+1+n,a[i])-b;29 for(int i=2;i&lt;=n;++i) fa[i]=read(),son[fa[i]].push_back(i);30&#125;3132inline int query(int qid,int l,int r,int pos)33&#123;34 if(!qid) return 0;35 if(l&gt;pos) return sum[qid];36 int m=(l+r)&gt;&gt;1;37 if(m&gt;pos) return query(ris[qid],m+1,r,pos)+query(les[qid],l,m,pos);38 return query(ris[qid],m+1,r,pos);39&#125;4041inline int merge(int u,int v)//the core42&#123;43 if(!u) return v;//某个没有，就直接用另一个，儿子信息可以直接用，不需要更新44 if(!v) return u;45 int t = ++cnt;//都有，就另建一个点记录合并后的信息46 sum[t]=sum[u]+sum[v];47 les[t]=merge(les[u],les[v]);//并且维护新节点的儿子信息48 ris[t]=merge(ris[u],ris[v]);49 return t;50&#125;5152inline void modify(int&amp; qid,int l,int r,int pos)//add the current point53&#123;54 if(!qid) qid=++cnt;55 ++sum[qid];56 if(l==r) return;57 int m=(l+r)&gt;&gt;1;58 if(m&gt;=pos) modify(les[qid],l,m,pos);59 else modify(ris[qid],m+1,r,pos);60&#125;6162inline int dfs(int now)63&#123;64 for(int i=0;i&lt;son[now].size();++i)65 &#123;66 dfs(son[now][i]);67 pid[now]=merge(pid[now],pid[son[now][i]]);68 &#125;69 ans[now]=query(pid[now],1,n,id[now]);70 modify(pid[now],1,n,id[now]);//add the current point71&#125;7273int main()74&#123;75 readin();76 dfs(1);77 for(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);78 return 0;79&#125;","permalink":"http://sher-wu.github.io/2019/12/06/BZOJ4756/","photos":[]},{"tags":[{"name":"组合概率","slug":"组合概率","permalink":"http://sher-wu.github.io/tags/%E7%BB%84%E5%90%88%E6%A6%82%E7%8E%87/"}],"title":"UVA11637","date":"2019/11/28","text":"UVA11637 - Garbage Remembering Exam 题意：&emsp;&emsp;大概意思是，有n个单词，分别打乱放在一个环形的，一个非环形里面，环形的两个单词距离为顺时针逆时针的最小值，非环形的就是位置的差的绝对值，如果有一对单词，在两个里面的距离都是不大于k，那么这单词为无效单词，问平均会出现多少个无效单词 思路：&emsp;&emsp;组合概率，假设在非环形形成了一个随机序列，那么我们给它标号1-n,如果我们能分别算出1-n的有效概率，那么就等于算出了无效概率，那么有效概率等于和它距离大于k的那些位置的所有单词拿出来，假设有x个，在环形序列中选一个位置放这个单词，然后它周围的2k的位置（因为是环形序列）要放入这些x个，就是x个选2k个放进去，再全排列，然后剩下n-2k-1个位置再全排列，然后总情况数为n的全排列，所以这样公式一组合起来就是nC(2k,x)2k!(n−2k−1)!/n!，化简一下公式得到x!(n−2k−1)!/(x−2k)!/(n−1)!，这个数值无法直接运算，然后观察能发现他的分子和分母可以合起来考虑变成乘除的项数相同，分子为(n−2k−1)∗(n−2k−2)∗…∗(x−2k+1)，分母为(n−1)∗(n−2)∗…∗(x+1)，那么就可以先递推预处理出一个p数组，p[x]就表示原公式解，那么整个答案为就是非环形序列每个位置的概率*1求出期望，然后累加求总和，最后再用n减去该值得到无效单词的期望。 1#include &lt;cstdio&gt;2#include &lt;cstring&gt;3#include &lt;algorithm&gt;4using namespace std;5//转化计算式，变成多个x-i/n-i相乘（x指在非环中当前数在它k范围外数的个数），然后预处理 6const int N = 100005;78int n, k;9double p[N];1011void init(int n, int k) &#123;12 memset(p, 0, sizeof(p));13 p[n - 1] = 1.0;14 for (int i = n - 1; i &gt; 2 * k; i--) &#123;15 p[i - 1] = p[i] * (i - 2 * k) * 1.0 / (i * 1.0) ;16 &#125;17&#125;1819double solve(int n, int k) &#123;20 init(n, k);21 double ans = 0;22 for (int i = 1; i &lt;= n; i++) &#123;23 int x = max(i - k - 1, 0) + max(n - i - k, 0);24 ans += p[x];25 &#125;26 return n - ans;27&#125;2829int main() &#123;30 int cas = 0;31 while (~scanf(\"%d%d\", &amp;n, &amp;k) &amp;&amp; n || k) &#123;32 printf(\"Case %d: %.4lf\\n\", ++cas, solve(n, k));33 &#125;34 return 0;35&#125;","permalink":"http://sher-wu.github.io/2019/11/28/UVA11637/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ1070","date":"2019/11/27","text":"BZOJ1070 [SCOI2007] 修车 Description 同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input 第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。 Output 最小平均等待时间，答案精确到小数点后2位。 Sample Input12 223 231 4 Sample Output11.50 HINT数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60),(1&lt;=T&lt;=1000) 思路：&emsp;&emsp;对同一个技术人员，如果车i倒数第x个被修理，那么该车对总时间的贡献就是tix。每个技术人员都可以把任何一辆车倒数第1个修，第2个修…第n个修，那么他们对总时间分别有不同的贡献。&emsp;&emsp;因而建图：s到所有车连flow=1,cost=0的边，车向每个技工的倒数第x个位置连flow=1,cost=tix的边，每个技工的每个位置向t连flow=1,cost=0的边。 1#include&lt;bits/stdc++.h&gt;2using namespace std;3const int maxn = 2020;4const int INF = 1e9+7;5typedef long long ll;6int le,ri,sp[12][70];7struct MCMF&#123;8 struct Edge&#123;9 int from,to,cap,cost;10 Edge()&#123;&#125;11 Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost)&#123;&#125;12 &#125;;13 int n,m,s,t;14 vector&lt;Edge&gt; edges;15 vector&lt;int&gt; G[maxn];16 int inq[maxn];//inqueue17 int d[maxn];//dis18 int p[maxn];//pre19 int a[maxn];//flow20 void init()21 &#123;22 for(int i=0;i&lt;=n;++i) G[i].clear();23 edges.clear();24 &#125;25 void AddEdge(int from,int to,int cap,int cost)26 &#123;27 edges.push_back(Edge(from,to,cap,cost));28 edges.push_back(Edge(to,from,0,-cost));29 m=edges.size();30 G[from].push_back(m-2);31 G[to].push_back(m-1);32 &#125;33 bool BF(int&amp; flow,int&amp; cost)34 &#123;35 for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0;36 d[s]=0,inq[s]=1,p[s]=0,a[s]=INF;37 queue&lt;int&gt; Q;38 Q.push(s);39 while(!Q.empty())40 &#123;41 int u=Q.front();Q.pop();42 inq[u]=0;43 //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;G[u].size()&lt;&lt;' '&lt;&lt;d[u]&lt;&lt;'\\n';44 for(int i=0;i&lt;G[u].size();++i)45 &#123;46 Edge&amp; e=edges[G[u][i]];47 if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost)48 &#123;49 d[e.to]=d[u]+e.cost;50 p[e.to]=G[u][i];51 a[e.to]=min(a[u],e.cap);52 if(!inq[e.to])53 &#123;54 Q.push(e.to);55 inq[e.to]=1;56 &#125;57 &#125;58 &#125;59 &#125;60 if(d[t]==INF) return false;61 flow+=a[t];62 cost+=d[t]*a[t];63 int u=t;64 while(u!=s)65 &#123;66 edges[p[u]].cap-=a[t];67 edges[p[u]^1].cap+=a[t];68 u=edges[p[u]].from;69 &#125;70 return true;71 &#125;72 int Mincost()73 &#123;74 int flow=0,cost=0;75 //cout&lt;&lt;m&lt;&lt;endl;76 while(BF(flow,cost));77 //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl;78 return cost;79 &#125;80&#125;NF;8182inline int read()&#123;83 int x=0,f=1;84 char ch=getchar();85 while(ch&lt;'0'||ch&gt;'9')&#123;86 //if(ch=='-') f=-1;87 ch=getchar();88 &#125;89 while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;90 x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);91 ch=getchar();92 &#125;93 return x;94&#125;9596inline void readin()97&#123;98 int temp;99 le=read(),ri=read();100 NF.s=0;101 NF.n=NF.t=ri*(le+1)+1;102 for(int i=1;i&lt;=ri;++i) NF.AddEdge(0,i,1,0);103 for(int i=1;i&lt;=ri;++i) for(int j=1;j&lt;=le;++j)104 &#123;105 sp[j][i]=read();106 for(int k=1;k&lt;=ri;++k) NF.AddEdge(i,j*ri+k,1,k*sp[j][i]);107 &#125;108 for(int i=ri+1;i&lt;NF.t;++i) NF.AddEdge(i,NF.t,1,0);109&#125;110111int main()112&#123;113 NF.init();114 readin();115 printf(\"%.2lf\",1.0*NF.Mincost()/ri);116 return 0;117&#125;","permalink":"http://sher-wu.github.io/2019/11/27/BZOJ1070/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ2879","date":"2019/11/26","text":"BZOJ2879 [NOI2012] 美食节 DescriptionCZ市为了欢迎全国各地的同学，特地举办了一场盛大的美食节。作为一个喜欢尝鲜的美食客，小M自然不愿意错过这场盛宴。他很快就尝遍了美食节所有的美食。然而，尝鲜的欲望是难以满足的。尽管所有的菜品都很可口，厨师做菜的速度也很快，小M仍然觉得自己桌上没有已经摆在别人餐桌上的美食是一件无法忍受的事情。于是小M开始研究起了做菜顺序的问题，即安排一个做菜的顺序使得同学们的等待时间最短。小M发现，美食节共有n种不同的菜品。每次点餐，每个同学可以选择其中的一个菜品。总共有m个厨师来制作这些菜品。当所有的同学点餐结束后，菜品的制作任务就会分配给每个厨师。然后每个厨师就会同时开始做菜。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。此外，小M还发现了另一件有意思的事情: 虽然这m个厨师都会制作全部的n种菜品，但对于同一菜品，不同厨师的制作时间未必相同。他将菜品用1, 2, …, n依次编号，厨师用1, 2, …, m依次编号，将第j个厨师制作第i种菜品的时间记为 ti,j 。小M认为：每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。换句话说，如果一个同学点的菜是某个厨师做的第k道菜，则他的等待时间就是这个厨师制作前k道菜的时间之和。而总等待时间为所有同学的等待时间之和。现在，小M找到了所有同学的点菜信息: 有 pi 个同学点了第i种菜品（i=1, 2, …, n）。他想知道的是最小的总等待时间是多少。 Input输入文件的第1行包含两个正整数n和m，表示菜品的种数和厨师的数量。 第2行包含n个正整数，其中第i个数为pi，表示点第i种菜品的人数。 接下来有n行，每行包含m个非负整数，这n行中的第i行的第j个数为ti,j，表示第j个厨师制作第i种菜品所需的时间。 输入文件中每行相邻的两个数之间均由一个空格隔开，行末均没有多余空格。 Output输出仅一行包含一个整数，为总等待时间的最小值。 Sample Input3 2 3 1 1 5 7 3 6 8 9 Sample Output47 样例说明 厨师1先制作1份菜品2，再制作2份菜品1。点这3道菜的3个同学的等待时间分别为3，3+5=8，3+5+5=13。厨师2先制作1份菜品1，再制作1份菜品3。点这2道菜的2个同学的等待时间分别为7，7+9=16。总等待时间为3+8+13+7+16=47。虽然菜品1和菜品3由厨师1制作更快，如果这些菜品都由厨师1制作，总等待时间反而更长。如果按上述的做法，将1份菜品1和1份菜品3调整到厨师2制作，这样厨师2不会闲着，总等待时间更短。可以证明，没有更优的点餐方案。 数据规模及约定对于100%的数据，n &lt;= 40, m &lt;= 100, p &lt;= 800, ti,j &lt;= 1000（其中p = ∑pi，即点菜同学的总人数）。 题意：&emsp;&emsp;n种菜m个厨师，第j个厨师做第i个菜要t[i][j]秒，每个菜点了ai份，顾客等待时间为从开始到他这份菜做完的时间，问等待总时间是多少。 思路：&emsp;&emsp;与「BZOJ1070」[SCOI2007]修车类似，只是数据规模增大了。&emsp;&emsp;因而，需要用到动态加点的思想。就是说，在我考虑下一个让谁做哪种的菜的时候，它只会是某一位厨师的倒数的第x道菜，因为如果让他把这道菜放在倒数第x+1道菜来做的话，肯定没有放在倒数第x道菜更优。因而，只有当一位厨师做了倒数第x道菜后（该厨师的倒数第x位置有了流量后），才允许他做倒数第x+1道菜（在菜与该厨师的倒数第x+1位置之间连边）。其他和BZOJ1070相似。 1#include&lt;bits/stdc++.h&gt;2using namespace std;3const int maxn = 1e5+20;4const int INF = 1e9+7;5typedef long long ll;6//建边的时候建错了，以及要避免变量的重名，MCMF中的n，m不是题目给的n，m的意思 7//cai是菜数，cook是厨师数，people是顾客数，sp=spend8int cai,cook,sp[50][110],people;9struct MCMF&#123;10 struct Edge&#123;11 int from,to,cap,cost;12 Edge()&#123;&#125;13 Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost)&#123;&#125;14 &#125;;15 int n,m,s,t;16 vector&lt;Edge&gt; edges;17 vector&lt;int&gt; G[maxn];18 int inq[maxn];//inqueue19 int d[maxn];//dis20 int p[maxn];//pre21 int a[maxn];//flow22 void init()23 &#123;24 for(int i=0;i&lt;=n;++i) G[i].clear();25 edges.clear();26 &#125;27 void AddEdge(int from,int to,int cap,int cost)28 &#123;29 edges.push_back(Edge(from,to,cap,cost));30 edges.push_back(Edge(to,from,0,-cost));31 m=edges.size();32 G[from].push_back(m-2);33 G[to].push_back(m-1);34 &#125;35 bool BF(int&amp; flow,int&amp; cost)36 &#123;37 for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0;38 d[s]=0,inq[s]=1,p[s]=0,a[s]=INF;39 queue&lt;int&gt; Q;40 Q.push(s);41 while(!Q.empty())42 &#123;43 int u=Q.front();Q.pop();44 inq[u]=0;45 //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;G[u].size()&lt;&lt;' '&lt;&lt;d[u]&lt;&lt;'\\n';46 for(int i=0;i&lt;G[u].size();++i)47 &#123;48 Edge&amp; e=edges[G[u][i]];49 if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost)50 &#123;51 d[e.to]=d[u]+e.cost;52 p[e.to]=G[u][i];53 a[e.to]=min(a[u],e.cap);54 if(!inq[e.to])55 &#123;56 Q.push(e.to);57 inq[e.to]=1;58 &#125;59 &#125;60 &#125;61 &#125;62 if(d[t]==INF) return false;63 flow+=a[t];64 cost+=d[t]*a[t];65 int u=t;66 while(u!=s)67 &#123;68 edges[p[u]].cap-=a[t];69 edges[p[u]^1].cap+=a[t];70 u=edges[p[u]].from;71 &#125;72 return true;73 &#125;74 int Mincost()75 &#123;76 int flow=0,cost=0;77 //cout&lt;&lt;m&lt;&lt;endl;78 while(BF(flow,cost))79 &#123;80 int x=edges[p[t]].from,y=(x-cai)/people+1,z=(x-cai)%people;81 AddEdge(x+1,t,1,0);82 for(int i=1;i&lt;=cai;++i) AddEdge(i,x+1,1,((z+1)*sp[i][y]));83 //cout&lt;&lt;edges[p[t]].from&lt;&lt;' '&lt;&lt;flow&lt;&lt;' '&lt;&lt;cost&lt;&lt;endl;84 //cout&lt;&lt;m&lt;&lt;endl;85 &#125;86 //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl;87 return cost;88 &#125;89&#125;NF;9091inline int read()&#123;92 int x=0,f=1;93 char ch=getchar();94 while(ch&lt;'0'||ch&gt;'9')&#123;95 //if(ch=='-') f=-1;96 ch=getchar();97 &#125;98 while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;99 x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);100 ch=getchar();101 &#125;102 return x;103&#125;104105inline void readin()106&#123;107 int temp;108 cai=read(),cook=read();109 for(int i=1;i&lt;=cai;++i)110 &#123;111 temp=read();112 NF.AddEdge(0,i,temp,0);113 people+=temp;114 &#125;115 NF.s=0;116 NF.n=NF.t=cai+people*cook+1;117 for(int i=1;i&lt;=cai;++i) for(int j=1;j&lt;=cook;++j)118 &#123;119 sp[i][j]=read();120 NF.AddEdge(i,cai+(j-1)*people+1,1,sp[i][j]);121 &#125;122 for(int i=1;i&lt;=cook;++i) NF.AddEdge(cai+(i-1)*people+1,NF.t,1,0);123&#125;124125int main()126&#123;127 NF.init();128 readin();129 cout&lt;&lt;NF.Mincost();130 return 0;131&#125;","permalink":"http://sher-wu.github.io/2019/11/26/BZOJ2879/","photos":[]},{"tags":[{"name":"权值线段树","slug":"权值线段树","permalink":"http://sher-wu.github.io/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"K小值","slug":"K小值","permalink":"http://sher-wu.github.io/tags/K%E5%B0%8F%E5%80%BC/"}],"title":"HDU6464","date":"2019/11/25","text":"HDU6464 免费送气球 Description&emsp;&emsp;又到了GDUT一年一度的程序设计竞赛校赛的时间啦。同学们只要参加校赛，并且每解出一道题目就可以免费获得由ACM协会和集训队送出的气球一个。听到这个消息，JMC也想参加免费拿气球。可是，由于JMC太菜了而被禁止参赛，于是他找到你想让你帮忙参加比赛，可以通过执行下面的C++程序解决问题后获得气球并送给他。JMC保证了下面的程序一定能获得正确的结果。 1void solve(int Q, int type[], long long first[], long long second[]) &#123;2 vector&lt;long long&gt; vec;3 for (int i = 0; i &lt; Q; ++i) &#123;4 if (type[i] == 1) &#123;5 long long k = first[i], val = second[i];6 while (k--) &#123;7 vec.push_back(val);8 &#125;9 &#125;10 else if (type[i] == 2) &#123;11 sort(vec.begin(), vec.end());12 long long l = first[i] - 1, r = second[i], res = 0;13 while (l &lt; r) &#123;14 res = (res + vec[l++]) % 1000000007;15 &#125;16 printf(\"%lld\\n\", res);17 &#125;18 &#125;19&#125; 为防止你被JMC的代码搞到头晕目眩，JMC特意给出了问题的文字描述。已知一开始有一个空序列，接下来有Q次操作，每次操作给出type、first和second三个值。当type为1时，意味着该操作属于第一种操作：往序列尾部添加first个second数。当type为2时，意味着该操作属于第二种操作：查询序列中第first小至第second小的数值之和（一共有(second - first + 1)个数被累加），并将结果对1000000007取模后输出。Input单组数据第一行一个Q（1 &lt;= Q &lt;= 1e5），代表Q次操作。接下来有Q行，每行包含三个整数type、first和second；其中1 &lt;= type &lt;= 2。当type等于1时，0 &lt;= first,second &lt; 1e9。当type等于2时，1 &lt;= first &lt;= second，且first和second均不大于目前已添加进序列的数的数量。 Output对于每次操作二，将结果对1000000007取模后输出。 Sample Input1621 5 131 6 342 2 552 4 861 2 272 4 8 Sample Output1421139 思路：可以当成权值线段树的模板的题。关键在于query的处理。全在左直接算左儿子，全在右要减去左儿子再算右儿子。两边都有要le到左儿子右端点+右儿子左端点到ri. 1#include&lt;bits/stdc++.h&gt;2using namespace std;3const int maxn=1e5+10;4const int maxm=1e9+7;5typedef long long ll;67struct func&#123;8 int type;9 ll fir,sec;10&#125;q[maxn];11ll a[maxn],t;12ll tree[4*maxn],sum[4*maxn];1314void pushup(int now)15&#123;16 tree[now]=tree[now&lt;&lt;1]+tree[now&lt;&lt;1|1];17 sum[now]=(sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1])%maxm;18&#125;1920void insert(int now,int pos,int le,int ri,int num)21&#123;22 if(le==ri)23 &#123;24 tree[now]+=num;25 sum[now]=tree[now]%maxm*a[le]%maxm;26 return;27 &#125;28 int mid=(le+ri)&gt;&gt;1;29 if(pos&lt;=mid) insert(now&lt;&lt;1,pos,le,mid,num);30 else insert(now&lt;&lt;1|1,pos,mid+1,ri,num);31 pushup(now);32&#125;3334ll query(int now,int le,int ri,ll fir,ll sec)//WA了两发的地方。没注意到fir和sec可以爆int35&#123;36 ll sums=0;37 if(fir==1&amp;&amp;tree[now]==sec) return sum[now]%maxm;38 if(le==ri) return (sec-fir+1)%maxm*a[le]%maxm;39 int mid=(le+ri)&gt;&gt;1;40 if(sec&lt;=tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1,le,mid,fir,sec)%maxm;//关键步骤！！！41 else if(fir&gt;tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1|1,mid+1,ri,fir-tree[now&lt;&lt;1],sec-tree[now&lt;&lt;1])%maxm;42 else43 &#123;44 sums=(query(now&lt;&lt;1,le,mid,fir,tree[now&lt;&lt;1])+query(now&lt;&lt;1|1,mid+1,ri,1,sec-tree[now&lt;&lt;1]))%maxm;45 &#125;46 return sums;47&#125;4849void run()50&#123;51 int Q;52 cin&gt;&gt;Q;53 for(int i=1;i&lt;=Q;i++)54 &#123;55 scanf(\"%d%lld%lld\",&amp;q[i].type,&amp;q[i].fir,&amp;q[i].sec);56 if(q[i].type==1) a[++t]=q[i].sec;57 &#125;58 sort(a+1,a+t+1);59 t=unique(a+1,a+t+1)-(a+1);//WA了一发的地方。权值线段树必须要排序后去重。unique返回值的意思是剩余长度60 for(int i=1;i&lt;=Q;i++)61 &#123;62 if(q[i].type==1)63 &#123;64 insert(1,lower_bound(a+1,a+t+1,q[i].sec)-a,1,t,q[i].fir);65 &#125;66 else67 &#123;68 cout&lt;&lt;query(1,1,t,q[i].fir,q[i].sec)&lt;&lt;endl;69 &#125;70 &#125;71&#125;7273int main()74&#123;75 run();76 return 0;77&#125;","permalink":"http://sher-wu.github.io/2019/11/25/HDU6464/","photos":[]},{"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计数排序","slug":"计数排序","permalink":"http://sher-wu.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}],"title":"CF558E","date":"2019/11/24","text":"CF558E A Simple Task 5 seconds per testThis task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non-decreasing order if k = 1 or in non-increasing order if k = 0.Output the final string after applying the queries. InputThe first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters. Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, ). OutputOutput one line, the string S after applying the queries. Examplesinput110 52abacdabcda37 10 045 8 151 4 063 6 077 10 1 output1cbcaaaabdd input110 12agjucbvdfk31 10 1 output1abcdfgjkuv NoteFirst sample test explanation: 题意：给你一串字符串，每次操作对一段区间内的字符串作升序或降序排序。输出所有操作后的字符串。 错误思路：把az依次赋以126的值，然后做区间的修改。。。写到一半就暴毙了 思路：&emsp;&emsp;这是直接听归神例会讲的方法。为az各建立一棵线段树，然后把字符放入它自己的线段树中。每次区间排序的时候，区间求该字符的个数，区间清空，然后接着之前的顺序赋值。&emsp;&emsp;比如ababa，变为升序时，t=1，1（1+3-1）变为a，然后t变为4，4~（4+2-1）变为b.&emsp;&emsp;复杂度O（m*26logn） 1#include&lt;bits/stdc++.h&gt;2using namespace std;3const int maxn=1e5+10;45int tree[30][4*maxn],lazy[30][4*maxn];6int n,m;7char c;8//lazy -1 未使用, 0或1 区间赋值为0或19void pushup(int trnum,int now)10&#123;11 tree[trnum][now]=tree[trnum][now&lt;&lt;1]+tree[trnum][now&lt;&lt;1|1];12&#125;1314void pushdown(int trnum,int num,int l,int mid,int r)15&#123;16 if(lazy[trnum][num]==0)17 &#123;18 tree[trnum][num&lt;&lt;1]=tree[trnum][num&lt;&lt;1|1]=lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=0;19 lazy[trnum][num]=-1;20 &#125;21 else if(lazy[trnum][num]==1)22 &#123;23 tree[trnum][num&lt;&lt;1]=mid-l+1;24 tree[trnum][num&lt;&lt;1|1]=r-mid;25 lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=1;26 lazy[trnum][num]=-1;27 &#125;28&#125;2930void addline(int trnum,int num,int le,int ri,int l,int r)31&#123;32 if(l&gt;=le&amp;&amp;r&lt;=ri)33 &#123;34 tree[trnum][num]=r-l+1;35 lazy[trnum][num]=1;36 return;37 &#125;38 int mid=(l+r)&gt;&gt;1;39 pushdown(trnum,num,l,mid,r);40 if(mid&gt;=le) addline(trnum,num&lt;&lt;1,le,ri,l,mid);41 if(mid&lt;ri) addline(trnum,num&lt;&lt;1|1,le,ri,mid+1,r);42 pushup(trnum,num);43&#125;4445void add(int num,int pos,int trnum,int l,int r)46&#123;47 if(l==r)48 &#123;49 tree[trnum][num]=1;50 return;51 &#125;52 int mid=(l+r)&gt;&gt;1;53 if(pos&lt;=mid) add(num&lt;&lt;1,pos,trnum,l,mid);54 else add(num&lt;&lt;1|1,pos,trnum,mid+1,r);55 pushup(trnum,num);56&#125;//其实add可以和addline合并但是当时没想到这么多就先写了个单点的5758int counts(int trnum,int num,int le,int ri,int l,int r)59&#123;60 if(l&gt;=le&amp;&amp;r&lt;=ri)61 &#123;62 lazy[trnum][num]=0;63 int t=tree[trnum][num];64 tree[trnum][num]=0;65 return t;66 &#125;67 int mid=(l+r)&gt;&gt;1,sum=0;68 pushdown(trnum,num,l,mid,r);69 if(mid&gt;=le) sum+=counts(trnum,num&lt;&lt;1,le,ri,l,mid);70 if(mid&lt;ri) sum+=counts(trnum,num&lt;&lt;1|1,le,ri,mid+1,r);71 pushup(trnum,num);72 return sum;73&#125;7475void run()76&#123;77 cin&gt;&gt;n&gt;&gt;m;78 c=getchar();79 for(int i=1;i&lt;=n;i++)80 &#123;81 c=getchar();82 add(1,i,c-'a',1,n);83 &#125;84 while(m--)85 &#123;86 int le,ri,t,xu,totnum;87 scanf(\"%d%d%d\",&amp;le,&amp;ri,&amp;xu);88 89 if(xu)90 &#123;91 t=le;92 for(int i=0;i&lt;26;i++)93 &#123;94 totnum=counts(i,1,le,ri,1,n);95 //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;totnum&lt;&lt;endl;96 if(totnum)97 &#123;98 addline(i,1,t,t+totnum-1,1,n);99 t+=totnum;100 &#125;101 &#125;102 &#125;103 else104 &#123;105 t=ri;106 for(int i=0;i&lt;26;i++)107 &#123;108 totnum=counts(i,1,le,ri,1,n);109 //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;totnum&lt;&lt;endl;110 if(totnum)111 &#123;112 addline(i,1,t-totnum+1,t,1,n);113 t-=totnum;114 &#125;115 &#125;116 &#125;117 &#125;118 for(int i=1;i&lt;=n;i++)119 &#123;120 for(int j=0;j&lt;26;j++)121 &#123;122 if(counts(j,1,i,i,1,n))123 &#123;124 printf(\"%c\",'a'+j);125 break;126 &#125;127 //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;128 &#125;129 &#125;130&#125;131132void init()133&#123;134 memset(lazy,-1,sizeof(lazy));135&#125; 136137int main()138&#123;139 if(fopen(\"test.txt\",\"r\")!=NULL)140 freopen(\"test.txt\",\"r\",stdin);141 init();142 run();143 return 0;144&#125;","permalink":"http://sher-wu.github.io/2019/11/24/CF558E/","photos":[]},{"tags":[{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"位运算","slug":"位运算","permalink":"http://sher-wu.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"title":"CF1174D","date":"2019/11/23","text":"CF1174D Ehab and the Expected XOR Problem DescriptionGiven two integers n and x, construct an array that satisfies the following conditions:for any element ai in the array, $1&lt;=ai&lt;2n$;there is no non-empty subsegment with bitwise XOR equal to 0 or x,its length l should be maximized.A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. InputThe only line contains two integers n and x (1≤n≤18, 1≤x&lt;218). OutputThe first line should contain the length of the array l.If l is positive, the second line should contain l space-separated integers a1, a2, …, al (1≤ai&lt;2n) — the elements of the array a.If there are multiple solutions, print any of them. Examples1input23 53output4356 1 36input72 48output93101 3 111input121 113output140 NoteIn the first example, the bitwise XOR of the subsegments are {6,7,4,1,2,3}. 题意：&emsp;&emsp;构造一个数列，元素为1~2^n的数，使得数列的任意子段的XOR和均不等于0与X。求数列的长度和任意一个解。 思路：&emsp;&emsp;最重要的：想到取构造前缀XOR和数组，而非直接去构造数组ai。&emsp;&emsp;具体的：构造前缀XOR和数组bi，则al^al+1^···^ar=bl-1^br.则不等于0-&gt;任意的bi与bj不相等。不等于X-&gt;若bi^bj=X，则只能取其一（代码中取了更小的）。遍历一遍所有数即可。然后用前缀数组算出原数组。&emsp;&emsp;时间复杂度O（2^n） 1#include&lt;bits&#x2F;stdc++.h&gt;2using namespace std;3typedef long long ll;4const int maxn &#x3D; 3e6+10;5int n,x,t[maxn],num,f[20],cou[maxn];&#x2F;&#x2F;cou为输出，t[i]&#x3D;1表示数组b不能选i，实际上用一个即可67int main()8&#123;9 cin&gt;&gt;n&gt;&gt;x;10 t[0]&#x3D;t[x]&#x3D;1;11 for(int i&#x3D;1;i&lt;(ll)(pow(2,n));i++)12 if(t[i]&#x3D;&#x3D;0)13 cou[++num]&#x3D;i,t[x^i]&#x3D;1;&#x2F;&#x2F;i^j&#x3D;x &lt;&#x3D;&#x3D;&gt; i^x&#x3D;j ,让之后选的数不为i^x或x就行14 cout&lt;&lt;num&lt;&lt;endl;15 if(num!&#x3D;0)16 cout&lt;&lt;cou[1]&lt;&lt;&#39; &#39;;17 for(int i&#x3D;1;i&lt;num;i++)18 cout&lt;&lt;(cou[i]^cou[i+1])&lt;&lt;&#39; &#39;;19 return 0;20&#125;","permalink":"http://sher-wu.github.io/2019/11/23/CF1174D/","photos":[]},{"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sher-wu.github.io/tags/DFS/"},{"name":"分治","slug":"分治","permalink":"http://sher-wu.github.io/tags/%E5%88%86%E6%B2%BB/"}],"title":"GYM101915K","date":"2019/11/18","text":"GYM101915K Chess Positions Description 一串01串，将其分成多个（可以为1）个区间，分别求和，要求所得的串是回文的。求总的种类数，结果对1e9+7取模 InputThe first line contains a single integer T denoting the number of test cases. Each test case consists of one line which contains the original sequence of zeros and ones. The length of every sequence is less than or equal to 50. OutputFor each test print one line containing one integer, the number of different ways to divide the original sequence leading to a sumindrome sequence modulo (1e9+7). Sample Input122011031001 Sample Output1428 NoteThe ways of dividing the sequence in the second sample are: (1001) -&gt; 2 (1)(001) -&gt; 1, 1 (100)(1) -&gt; 1, 1 (10)(01) -&gt; 1, 1 (1)(00)(1) -&gt; 1, 0, 1 (1)(0)(01) -&gt; 1, 0, 1 (10)(0)(1) -&gt; 1, 0, 1 (1)(0)(0)(1) -&gt; 1, 0, 0, 1 思路：回文数的要求就是从左和从右一样，那么从左开始和从右开始的总值一样时，就把这些值合并，再求剩下里面的回文的种类数。 1#include&lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4const ll maxn=1e9+7;5char a[60];6int dp[60][60];78void init()9&#123;10 memset(dp,-1,sizeof(dp));11&#125;1213ll dfs(int l,int r)14&#123;15 //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;'\\n';16 if(l&gt;=r) return dp[l][r]=1;17 if(dp[l][r]!=-1) return dp[l][r];18 int &amp;tent=dp[l][r]=1;//这一块全部加起来作为中间项必定正确 19 int suml=0;20 for(int i=l;i&lt;r;i++)21 &#123;22 suml+=a[i]-'0';23 int sumr=0;24 for(int j=r;j&gt;i;j--)25 &#123;26 sumr+=a[j]-'0';27 if(suml&lt;sumr) break;28 if(suml==sumr) tent=(tent+dfs(i+1,j-1))%maxn;29 &#125;30 &#125;31 return tent;32&#125;3334int main()35&#123;36 //freopen(\"text.txt\",\"r\",stdin);37 int t;38 cin&gt;&gt;t;39 while(t--)40 &#123;41 init();42 scanf(\"%s\",a);43 printf(\"%lld\\n\",dfs(0,strlen(a)-1));44 &#125;45&#125;","permalink":"http://sher-wu.github.io/2019/11/18/GYM101915K/","photos":[]},{"tags":[{"name":"离散化","slug":"离散化","permalink":"http://sher-wu.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"搜索","permalink":"http://sher-wu.github.io/tags/%E6%90%9C%E7%B4%A2/"}],"title":"CF1119D","date":"2019/11/17","text":"CF1119D Frets On Fire DescriptionMiyako came to the flea kingdom with a ukulele. She became good friends with local flea residents and played beautiful music for them every day. In return, the fleas made a bigger ukulele for her: it has n strings, and each string has (1018+1) frets numerated from 0 to 1018. The fleas use the array s1,s2,…,sn to describe the ukulele’s tuning, that is, the pitch of the j-th fret on the i-th string is the integer si+j. Miyako is about to leave the kingdom, but the fleas hope that Miyako will answer some last questions for them. Each question is in the form of: “How many different pitches are there, if we consider frets between l and r (inclusive) on all strings?” Miyako is about to visit the cricket kingdom and has no time to answer all the questions. Please help her with this task! Formally, you are given a matrix with n rows and (1018+1) columns, where the cell in the i-th row and j-th column (0≤j≤1018) contains the integer si+j. You are to answer q queries, in the k-th query you have to answer the number of distinct integers in the matrix from the lk-th to the rk-th columns, inclusive. InputThe first line contains an integer n (1≤n≤100000) — the number of strings. The second line contains n integers s1,s2,…,sn (0≤si≤1018) — the tuning of the ukulele. The third line contains an integer q (1≤q≤100000) — the number of questions. The k-th among the following q lines contains two integers lk，rk (0≤lk≤rk≤1018) — a question from the fleas. OutputOutput one number for each question, separated by spaces — the number of different pitches. Examples1input2633 1 4 1 5 94357 760 278 178output95 10 18 1input2231 5000000000000000004251000000000000000000 100000000000000000060 10000000000000000007output82 1500000000000000000 题意：有n个以ai开头，依次+1的数列，问在每个数列中去li~ri项，总共有多少不相同的项 思路：li与ri怎么取并没有意义，只有长度才有意义。排序后求差，当长度-1&gt;=两相邻数之差时,小的数将没有贡献。Ⅰ 用离散化的方法，对差排序后对其进行叠加及保存(dxr用的&lt;1&gt;，且省去了离散化）Ⅱ &lt;1&gt; c[i] = b[i] + c[i-1] (b是差的排序数组）&emsp;&emsp;&emsp; 前后两数之差大于len的，都有贡献，小于len的全体，有c[i]的贡献Ⅱ &lt;2&gt; ans[num[i]]=ans[num[i-1]]+tot(num[i]-num[i-1]) (tot当前仍有贡献的数的个数)，用rec[i]来保存)&emsp;&emsp;&emsp; out[k]=ans[num[pos]]+(res[num[pos]])\\(len-num[pos])&emsp;&emsp;&emsp; 所求 = num[i]的总贡献+(len-num[i])间有效数个数*长度 DXR &lt;1&gt; : 1//总的来说，就是差大于len的，都有贡献，小于len的全体，有c[i]的贡献2//有一个极大的好处，就是没有用到离散化的知识点3#include &lt;cstdio&gt;4#include &lt;cstring&gt;5#include &lt;algorithm&gt;6#include &lt;cmath&gt;7using namespace std;8typedef unsigned long long ull;9const int NN = 110000;10int n, num;11ull b[NN], c[NN], tmp, h, len, l, r, ans, m, a[NN];1213bool cmp(ull a, ull b)14&#123;15 return a &lt; b;16&#125;1718int main()19&#123;20 //freopen(\"1.in\", \"r\", stdin);21 scanf(\"%d\", &amp;n);22 for (int i = 1; i &lt;= n; i++)23 &#123;24 scanf(\"%llu\", &amp;a[i]);25 &#125;26 //首先对a排序27 sort(a + 1, a + n + 1, cmp);2829 num = 0;30 for (int i = 2; i &lt;= n; i++)31 if (a[i] - a[i - 1])32 b[++num] = a[i] - a[i - 1]; //求两个大小相邻的，不同的数字之间（去重）的差33 sort(b + 1, b + num + 1, cmp);34 //对差排序，求部分和（因为差&lt;len的所有点都有部分重复，需要减去）35 c[0] = 0;36 for (int i = 1; i &lt;= num; i++)37 c[i] = b[i] + c[i - 1];38 //len到b[i]时，该数与该数-1有b[i]未重合39 //c[i]表示到第i个数时，如果len&gt;=b[i]，前面所有数的获得的有效数的总数40 /*41 for (int i=1; i&lt;=n; i++) printf(\"%d \", a[i]);42 printf(\"\\n\");43 for (int i=1; i&lt;=num; i++) printf(\"%d \", b[i]);44 printf(\"\\n\");45 for (int i=1; i&lt;=num; i++) printf(\"%d \", c[i]);46 printf(\"\\n\");47 */48 scanf(\"%d\", &amp;m);49 while (m--)50 &#123;51 scanf(\"%llu%llu\", &amp;l, &amp;r);52 len = r - l + 1; //由题目，最终答案与起点终点无关，至于起点与终点之间的距离有关53 //由题, 每个点与上一个点重复的个数=len-它与上一个点的差（若差&gt;=len, 则无重复点）54 //num是差的个数，有效数的总数为num+155 ans = (num + 1) * len; //先将每个数字可以引出的新数都算上（很可能中间有重复的）56 tmp = lower_bound(b + 1, b + num + 1, len) - b; //找到比len小的最大的差，即为（tmp-1），57 ans -= len * (tmp - 1) - c[tmp - 1];58 //减去重复的个数（每个点仅考虑与上一个点重复的）59 //假设所有&lt;len的数都产生了重复，全部删去，再补上实际上未产生重复的60 //printf(\"\\n%llu\\n\", tmp);6162 printf(\"%llu \", ans);63 &#125;64 return 0;65&#125; MS &lt;1&gt; : 1//离线完成，极大的降低了复杂度2#include &lt;stdio.h&gt;3#include &lt;iostream&gt;4#include &lt;stdlib.h&gt;5#include &lt;string.h&gt;6#include &lt;algorithm&gt;7#include &lt;vector&gt;8#include &lt;map&gt;9using namespace std;10typedef long long ll;11typedef pair&lt;ll, ll&gt; P;12typedef pair&lt;P, int&gt; PP;13const int maxn = 1e5 + 100;14ll a[maxn], b[maxn];15P ans[maxn];16PP q[maxn];17bool cmp(PP p1, PP p2)18&#123;19 if (p1.first.second - p1.first.first &lt; p2.first.second - p2.first.first)20 return 1;21 else22 return 0;23&#125;24bool cmp1(PP p1, PP p2)25&#123;26 if (p1.second &lt; p2.second)27 return 1;28 else29 return 0;30&#125;31int main()32&#123;33 int n;34 cin &gt;&gt; n;35 for (int i = 0; i &lt; n; i++)36 cin &gt;&gt; a[i];37 sort(a, a + n);38 for (int i = 0; i &lt; n - 1; i++)39 b[i] = (a[i + 1] - a[i]);40 sort(b, b + n - 1);41 int t;42 cin &gt;&gt; t;43 for (int i = 0; i &lt; t; i++)44 &#123;45 cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second;46 q[i].second = i;47 &#125;48 sort(q, q + t, cmp);49 ll now = 0, coun = 0;50 for (int i = 0; i &lt; t; i++)51 &#123;52 ll cha = q[i].first.second - q[i].first.first + 1;53 while (coun != n - 1 &amp;&amp; cha &gt;= b[coun])54 &#123;55 now += b[coun];56 coun++;57 &#125;58 ans[i].first = q[i].second;59 ans[i].second = now + cha * (n - coun);60 &#125;61 sort(ans, ans + t);62 for (int i = 0; i &lt; t; i++)63 &#123;64 cout &lt;&lt; ans[i].second &lt;&lt; \" \";65 &#125;66&#125; YZM &lt;2&gt; : 1#include &lt;bits/stdc++.h&gt;2using namespace std;3const int maxn = 1e5 + 10;4typedef long long ll;5int n, q, tot;6ll s[maxn];7ll l, r, len;8map&lt;ll, ll&gt; vis, res, ans;9ll num[maxn], cnt;10ll out[maxn];11int main()12&#123;13 cin &gt;&gt; n;14 tot = n;15 for (int i = 1; i &lt;= n; ++i)16 scanf(\"%lld\", &amp;s[i]);17 sort(s + 1, s + n + 1);18 for (int i = 1; i &lt; n; ++i)19 &#123;20 ll p = s[i + 1] - s[i];21 if (!p)22 tot--;23 else if (!vis[p])24 num[++cnt] = p; //用num保存所有的数25 vis[p]++;26 &#125;27 //for(map&lt;ll,ll&gt;::iterator it=vis.begin();it!=vis.end();it++)28 //printf(\"%I64d:%I64d\\n\",it-&gt;first,it-&gt;second);29 sort(num + 1, num + cnt + 1);30 ans[0] = num[0] = 0;31 for (int i = 1; i &lt;= cnt; ++i)32 &#123;33 ans[num[i]] = ans[num[i - 1]] + tot * (num[i] - num[i - 1]);34 //到num[i]这个数为止，所有数的贡献=上一段的贡献+num[i-1]+1到num[i]间有效数的贡献35 //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ans[num[i]]&lt;&lt;endl;36 res[num[i - 1]] = tot;37 tot -= vis[num[i]]; //tot为下一段中仍有贡献的数的个数38 &#125;39 res[num[cnt]] = tot;40 //for(int i=0;i&lt;=cnt;++i)41 //printf(\"-&gt;%I64d:%I64d + %I64d\\n\",num[i],ans[num[i]],res[num[i]]);42 scanf(\"%d\", &amp;q);43 for (int k = 1; k &lt;= q; ++k)44 &#123;45 scanf(\"%lld%lld\", &amp;l, &amp;r);46 len = r - l + 1;47 int pos = upper_bound(num, num + cnt + 1, len) - num;48 pos--; //num[pos]&lt;=len49 //cout&lt;&lt;pos&lt;&lt;endl;50 //printf(\"pos:%d\\n\",pos);51 //printf(\"v:%I64d +:%I64d\\n\",ans[num[pos]],res[num[pos]]);52 out[k] = ans[num[pos]] + (res[num[pos]]) * (len - num[pos]);53 &#125;54 for (int k = 1; k &lt;= q; ++k)55 printf(\"%lld \", out[k]);56 return 0;57&#125;","permalink":"http://sher-wu.github.io/2019/11/17/CF1119D/","photos":[]},{"tags":[{"name":"DP","slug":"DP","permalink":"http://sher-wu.github.io/tags/DP/"}],"title":"PTA-L3-20","date":"2019/11/15","text":"PTA-L3-20 至多删三个字符 Description给定一个全部由小写英文字母组成的字符串，允许你至多删掉其中3个字符，结果可能有多少种不同的字符串？ Input输入在一行中给出全部由小写英文字母组成的、长度在区间 [4, 1e6​​] 内的字符串。 Output在一行中输出至多删掉其中 3 个字符后不同字符串的个数。 Sample Input1ababcc Sample Output125 Hint1删掉 0 个字符得到 \"ababcc\"。23删掉 1 个字符得到 \"babcc\", \"aabcc\", \"abbcc\", \"abacc\" 和 \"ababc\"。45删掉 2 个字符得到 \"abcc\", \"bbcc\", \"bacc\", \"babc\", \"aacc\", \"aabc\", \"abbc\", \"abac\" 和 \"abab\"。67删掉 3 个字符得到 \"abc\", \"bcc\", \"acc\", \"bbc\", \"bac\", \"bab\", \"aac\", \"aab\", \"abb\" 和 \"aba\"。 思路：为了避免重复，以及枚举或者组合数在此用起来不现实，因而使用DP。d[i][j]表示前i个字符中删除j个字符后得到的不同字符串的个数。则d[i][j+1]+=d[i-1][j]（删除第i个字符）&amp;&amp; d[i][j]+=d[i-1][j]（不删除第i个字符）如果只是这样转移肯定会有重复的。例如一个字符串cdabnaxy，你删除abn和删除bna后得到的字符串都是cdaxy。 这时候就要去重了，根据上面那个栗子可以发现对于一个字符s[i]，如果在i之前存在一个x使得s[x]==s[i]，那么删除[x,i-1]间的字符和删除[x+1,i]间的字符其实是重复的，等价的，那么d[i][j]就要减去d[x-1][j-(i-x)]，减去删除这段造成的重复串。 1#include &lt;bits/stdc++.h&gt;2using namespace std;3const int MAX = 1e6 + 5;4typedef long long ll;5char s[MAX];6ll d[MAX][4];7int main()8&#123;9 scanf(\"%s\", s + 1);10 int n = strlen(s + 1);11 d[0][0] = 1;12 for (int i = 1; i &lt;= n; i++)13 &#123;14 for (int j = 0; j &lt;= 3; j++)15 &#123;16 if (d[i - 1][j] == 0)17 continue;18 if (j &lt; 3)19 d[i][j + 1] += d[i - 1][j];20 d[i][j] += d[i - 1][j];21 for (int k = i - 1; k &gt;= 1 &amp;&amp; i - k &lt;= j; k--) //往前找到第一个k使得s[k]=s[i]22 &#123;23 if (s[k] == s[i])24 &#123;25 d[i][j] -= d[k - 1][j - (i - k)];26 break;27 &#125;28 &#125;29 &#125;30 &#125;31 printf(\"%lld\\n\", d[n][0] + d[n][1] + d[n][2] + d[n][3]);32 return 0;33&#125;","permalink":"http://sher-wu.github.io/2019/11/15/PTA-L3-20/","photos":[]},{"tags":[{"name":"贪心","slug":"贪心","permalink":"http://sher-wu.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"}],"title":"CF1041E","date":"2019/11/14","text":"CF Round #509 (Div.2) E. Tree Reconstruction Description1 second per testMonocarp has drawn a tree (an undirected connected acyclic graph) and then has given each vertex an index. All indices are distinct numbers from 1 to n. For every edge e of this tree, Monocarp has written two numbers: the maximum indices of the vertices of the two components formed if the edge e (and only this edge) is erased from the tree. Monocarp has given you a list of n−1 pairs of numbers. He wants you to provide an example of a tree that will produce the said list if this tree exists. If such tree does not exist, say so. InputThe first line contains one integer n (2≤n≤1000) — the number of vertices in the tree. Each of the next n−1 lines contains two integers ai and bi each ($1&lt;=ai&lt;bi&lt;=n$) — the maximal indices of vertices in the components formed if the i-th edge is removed. OutputIf there is no such tree that can produce the given list of pairs, print “NO” (without quotes). Otherwise print “YES” (without quotes) in the first line and the edges of the tree in the next n−1 lines. Each of the last n−1 lines should contain two integers xi and yi (1≤xi,yi≤n) — vertices connected by an edge. Note: The numeration of edges doesn’t matter for this task. Your solution will be considered correct if your tree produces the same pairs as given in the input file (possibly reordered). That means that you can print the edges of the tree you reconstructed in any order. Examplesinput1423 431 443 4 output1YES21 333 242 4 input1321 331 3 output1NO input1321 232 3 output1NO NotePossible tree from the first example. Dotted lines show edges you need to remove to get appropriate pairs. 题意：是说，要构建一个树，使得它砍掉每一条边时，左右的最大权值是给定的值。例如样例1，4-2-3-1，砍第一二条边左右最大都是4&amp;3，砍第三条是4&amp;1，符合题意，然后输出每一条边的左右节点。 思路：最最最基本的，它的某一边最大一定是n，否则直接No。如果n，x只出现了一次，那直接n，x相连即可。如果出现了两次，那么要在n与x中间加一个比x小的数i。如果三次。。。那么就直接是贪心，从最小的x开始，i也从1开始递增，根据n，x出现的次数多少决定在n，x中间加多少个数（次数-1）。 1#include&lt;bits/stdc++.h&gt;2using namespace std;34int n,a[1010],b[1010],c[1010],now,add[1010],nown=1;56int main()&#123;7 cin&gt;&gt;n;8 for(int i=1;i&lt;n;i++)&#123;9 int x,y;10 cin&gt;&gt;x&gt;&gt;y;11 if(x==n) a[y]++;//（x,n）中x的出现次数12 else if(y==n) a[x]++; 13 else14 &#123;15 cout&lt;&lt;\"NO\";16 return 0;17 &#125;18 &#125;19 int ch=1;20 for(int i=1;i&lt;n;i++)21 &#123;22 if(a[i])//没有就跳过23 &#123;24 int t=n;25 while(a[i]&gt;1&amp;&amp;nown&lt;=i)//是1，直接建边26 &#123;27 if(add[nown]==0)&#123;28 b[++now]=t;29 c[now]=nown;30 add[nown]=1;31 t=nown;32 a[i]--;33 &#125;34 nown++;35 &#125;36 if(nown&gt;i)//不是1，先往小的连，到1以后，再建边37 &#123;38 ch=0;39 break;40 &#125;41 b[++now]=t;42 c[now]=i;43 add[i]=1;44 a[i]--;45 &#125;46 &#125;47 if(ch==0)//（x,n）的次数少于剩余的小于x的数的总数了，No48 &#123;49 cout&lt;&lt;\"NO\";50 &#125;51 else52 &#123;53 cout&lt;&lt;\"YES\"&lt;&lt;endl;54 for(int i=1;i&lt;n;i++)55 &#123;56 cout&lt;&lt;b[i]&lt;&lt;' '&lt;&lt;c[i]&lt;&lt;endl;57 &#125;58 &#125;59 return 0;60&#125;","permalink":"http://sher-wu.github.io/2019/11/14/CF1041E/","photos":[]},{"tags":[{"name":"模拟","slug":"模拟","permalink":"http://sher-wu.github.io/tags/%E6%A8%A1%E6%8B%9F/"}],"title":"PTA-L1-64","date":"2019/11/13","text":"PTA-L1-64 估值一亿的AI核心代码 Description本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是： 无论用户说什么，首先把对方说的话在一行中原样打印出来；消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；把原文中所有大写英文字母变成小写，除了 I；把原文中所有独立的 can you、could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词；把原文中所有独立的 I 和 me 换成 you；把原文中所有的问号 ? 换成惊叹号 !；在一行中输出替换后的句子作为 AI 的回答。 Input输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。 Output按题面要求输出，每个 AI 的回答前要加上 AI: 和一个空格。 1输入样例：2 63Hello ?4 Good to chat with you5can you speak Chinese?6Really?7Could you show me 58What Is this prime? I,don 't know9输出样例：10 Hello ?11AI: hello!12 Good to chat with you13AI: good to chat with you14can you speak Chinese?15AI: I can speak chinese!16Really?17AI: really!18Could you show me 519AI: I could show you 520What Is this prime? I,don 't know21AI: what Is this prime! you,don't know 第一次出去比赛，rating拿了全组第一还是挺开心的。代码就懒得再写一遍了。讲白了就是一道码农模拟题，难点也主要就在特判怎么设。 1、从头开始检测空格，检测的连续的两个空格就连删直到只剩一个（用了char的strcpy，string的erase应该也行）2、删头尾的空格，与字符前面的空格3、变换所有大写字母与？-&gt;!4、开始输出{&emsp;&emsp;Ⅰ 输出个 ’AI: ‘&emsp;&emsp;Ⅱ 一位一位输出直到 a[i]==’\\0’&emsp;&emsp;Ⅲ 用连续的字符特判判定 “can you”&amp;&amp;“could you”，并使I+=7,i+=9;&emsp;&emsp;Ⅳ 判定I&amp;&amp;me前后是不是字符(是否独立）&emsp;&emsp;&emsp;&emsp; *A:65 a:97 0:48&emsp;&emsp;Ⅴ 输出’\\n‘}","permalink":"http://sher-wu.github.io/2019/11/13/PTA-L1-64/","photos":[]},{"tags":[{"name":"Introduct","slug":"Introduct","permalink":"http://sher-wu.github.io/tags/Introduct/"}],"title":"Hello World","date":"2019/11/11","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://sher-wu.github.io/2019/11/11/Hello%20World/","photos":[]}]}