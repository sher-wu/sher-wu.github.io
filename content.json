{"meta":{"title":"Welcome to sher-wu's home !","subtitle":"","description":"","author":"sher-wu","url":"http://sher-wu.github.io","root":"/"},"posts":[{"tags":[],"title":"Donot Forget!","date":"2099/12/31","text":"Donot Forget! 费用流 KM 树套树 trie树 bitset 徐州现场赛 J 徐州现场赛 单点修改+mex P4147 玉蟾宫 (单调栈) CF 1264C CF 1264E 带权 &amp; 种类 并查集 树链剖分 HDU4747 线段树 冲鸭！","permalink":"http://sher-wu.github.io/2099/12/31/Donot%20Forget!/","photos":[]},{"tags":[{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"CF1264E","date":"2019/12/19","text":"CF1264E Beautiful League 题意： n支球队，两两各打一场比赛，比赛只有胜败而无平局。有些比赛胜败已分，有些比赛尚未进行。问所有比赛结束后，满足A赢B,B赢C,C赢A的有序三元组(A,B,C)至多时，每场比赛的胜负情况。 思路： 如果莽求三元组的数量的话，会有一个问题，如何记录一个环。换句话说，就是怎样让它搜索结束再次走到A时知道这是个三元环。 因而，搜索是不现实的。那么换角度考虑。满足数=总数-不满足数，而不满足时，必为A胜B且A胜C。故我们可以知道，球队\\(i\\)胜了\\(a_i\\)场时，产生的不满足数为\\(a_i\\times(a_i-1)\\)（B,C有序），那么总不满足数为 \\(\\sum_{i=1}^{n}a_i\\times(a_i-1)=\\sum_{i=1}^{n}a_i^2-\\frac{n\\times (n-1)}{2}\\) 即问题变为使\\(\\sum_{i=1}^{n}a_i^2\\)尽可能小。球队i每再胜一场，将增加不满足数\\(2a_i+1\\)，\\(2a_i+3\\)，\\(2a_i+5\\)，...，\\(2a_i+2\\times(n-1-a_i)-1\\) 连边跑最小费用最大流。从S连1流,0费到比赛节点，再从比赛节点连1流,0费分别到比赛的两支队伍。从队伍连1流,费用如上的共\\(n-1-a_i\\)到T。跑完后根据比赛节点的的流量情况确定是哪支队赢了。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2000; const int INF = 1e9+7; typedef long long ll; int le,ri,tot,cpt[60][60],fir[maxn],sec[maxn]; struct MCMF&#123; struct Edge&#123; int from,to,cap,cost; Edge()&#123;&#125; Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost)&#123;&#125; &#125;; int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn];//inqueue int d[maxn];//dis int p[maxn];//pre int a[maxn];//flow void init() &#123; for(int i=0;i&lt;=n;++i) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost) &#123; edges.push_back(Edge(from,to,cap,cost)); edges.push_back(Edge(to,from,0,-cost)); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BF(int&amp; flow,int&amp; cost) &#123; for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0; d[s]=0,inq[s]=1,p[s]=0,a[s]=INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); inq[u]=0; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;G[u].size()&lt;&lt;' '&lt;&lt;d[u]&lt;&lt;'\\n'; for(int i=0;i&lt;G[u].size();++i) &#123; Edge&amp; e=edges[G[u][i]]; if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost) &#123; d[e.to]=d[u]+e.cost; p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap); if(!inq[e.to]) &#123; Q.push(e.to); inq[e.to]=1; &#125; &#125; &#125; &#125; if(d[t]==INF) return false; flow+=a[t]; cost+=d[t]*a[t]; int u=t; while(u!=s) &#123; edges[p[u]].cap-=a[t]; edges[p[u]^1].cap+=a[t]; u=edges[p[u]].from; &#125; return true; &#125; int Mincost() &#123; int flow=0,cost=0; //cout&lt;&lt;m&lt;&lt;endl; while(BF(flow,cost)); //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl; for(int i=le+1;i&lt;t;++i) &#123; if(!edges[G[i][1]].cap) cpt[fir[i]][sec[i]]=1,cpt[sec[i]][fir[i]]=0; else cpt[fir[i]][sec[i]]=0,cpt[sec[i]][fir[i]]=1; &#125; return cost; &#125; &#125;NF; inline int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; //if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x; &#125; inline void readin() &#123; int temp,win[60]=&#123;0&#125;,du[60]=&#123;0&#125;,wwin,llos; le=read(),ri=read(); for(int i=1;i&lt;=le;++i) for(int j=1;j&lt;=le;++j) if(i!=j) cpt[i][j]=2; NF.s=0; temp=le+1; for(int i=1;i&lt;=ri;++i) &#123; wwin=read(); llos=read(); cpt[wwin][llos]=1; cpt[llos][wwin]=0; &#125; for(int i=1;i&lt;=le;++i) for(int j=1;j&lt;=le;++j) if(cpt[i][j]==2) &#123; if(i&gt;j) continue; fir[temp]=i; sec[temp]=j; NF.AddEdge(0,temp,1,0); NF.AddEdge(temp,i,1,0); NF.AddEdge(temp++,j,1,0); ++du[i]; ++du[j]; &#125; else win[i]+=cpt[i][j]; NF.n=NF.t=temp; for(int i=1;i&lt;=le;++i) &#123; tot+=win[i]*win[i]; for(int j=1;j&lt;=du[i];++j) NF.AddEdge(i,NF.t,1,2*(win[i]+j)-1); &#125; &#125; int main() &#123; NF.init(); readin(); int p=NF.Mincost(); for(int i=1;i&lt;=le;++i,puts(\"\")) for(int j=1;j&lt;=le;++j) printf(\"%d\",cpt[i][j]); //printf(\"%d %d\",p,le*(le-1)*(le-2)/6-(tot+p-le*(le-1)/2)/2); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/12/19/CF1264E/","photos":[]},{"tags":[{"name":"三维DP","slug":"三维DP","permalink":"http://sher-wu.github.io/tags/%E4%B8%89%E7%BB%B4DP/"}],"title":"CF1272F","date":"2019/12/19","text":"CF1272F Two Bracket Sequences 题意： 求一个最短的合法的由 ( 和 ) 构成的字符串，且两个给定的由 ( 和 ) 构成的字符串是它的子序列。\\((length&lt;=200)\\) 思路： 合法就是指要先有 ( 再有 ) ，并且 ( 和 ) 数量相同。那么根据数据范围，可以考虑使用DP，并且在记录字符串长度的同时，还要记录 ( 的数量。 dp[i][j][k]表示考虑到第一个字符串的第i个字符(前i-1个已经考虑完了)，j类似。 k表示求出的前缀字符串中 ( 比 ) 多多少 ( \\(k\\geq0\\) ，不然字符串不合法)。 其值为还需要添加的后缀字符串的字符数。 那么递推式也就是判断一下当前这个字符是否和生成字符串里的字符相同就行了。 为了减小复杂度，用了记忆化搜索。 #include &lt;bits/stdc++.h&gt; #include &lt;cstring&gt; using namespace std; const int INF = 1e9 + 7; int slen, tlen; int dp[210][210][410]; char s[210], t[210]; char ji[210][210][410]; inline int search(int i, int j, int k) &#123; if (k &lt; 0 || k &gt; 400) return INF; if (dp[i][j][k] != -1) return dp[i][j][k]; if (i &gt; slen &amp;&amp; j &gt; tlen) return k; int le = search(i + (i &lt;= slen &amp;&amp; s[i] == '('), j + (j &lt;= tlen &amp;&amp; t[j] == '('), k + 1) + 1; int ri = search(i + (i &lt;= slen &amp;&amp; s[i] == ')'), j + (j &lt;= tlen &amp;&amp; t[j] == ')'), k - 1) + 1; ji[i][j][k] = le &lt; ri ? '(' : ')'; return dp[i][j][k] = min(le, ri); &#125; int main() &#123; memset(dp, -1, sizeof dp); scanf(\"%s%s\", s + 1, t + 1); slen = strlen(s + 1); tlen = strlen(t + 1); int ans = search(1, 1, 0), le = 1, ri = 1, _k = 0; while (le &lt;= slen || ri &lt;= tlen) &#123; printf(\"%c\", ji[le][ri][_k]); if (ji[le][ri][_k] == '(') le += (le &lt;= slen &amp;&amp; s[le] == '('), ri += (ri &lt;= tlen &amp;&amp; t[ri] == '('), ++_k; else le += (le &lt;= slen &amp;&amp; s[le] == ')'), ri += (ri &lt;= tlen &amp;&amp; t[ri] == ')'), --_k; &#125; while (_k--) putchar(')'); //printf(\"%d\", ans); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/12/19/CF1272F/","photos":[]},{"tags":[],"title":"华为杯-大连理工大学第12届大学生程序设计大赛题解","date":"2019/12/11","text":"\"华为杯\"大连理工大学第12届大学生程序设计大赛题解 Problem Designer / Porter: funer, cscyuge, Kinesis, Zeraful, ggwdwsbs Solution Author: Yzm007, Coca, Kinesis, sher_wu 戳我补题 难度排序： Easy：ANM Easy-Middle：HDI Middle：CK Middle-Hard：FLBG Hard：EJ A. 字符三角形 签到题。 N. 蓝桥杯！爆零！ 即统计积最多能被10整除几次，积中出现了几个10。 而10可以被分解成2*5，即统计n个数中共出现了几次2和5，取小即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,v,two,five; int main() &#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;v); for(;v%2==0;v/=2)two++; for(;v%5==0;v/=5)five++; &#125; printf(\"%d\\n\",min(two,five)); return 0; &#125; M. 后缀自动机求回旋字符串 长度为奇显然为NO，考虑长度为偶，此处以长度为8的s串为例。 1 2 3 4 5 6 7 8 若此串合法，需s[1]=s[5]，s[2]=s[6]，… 考虑后挪一位得到新串2 3 4 1，发现仍需满足上式。 因此直接判断即可，可以推广到长度为2*n的情形。 事实上，如将串首尾相接形成一个环，该操作相当于重新选择环的起点，但无论执行多少次操作，当前字母仍应与其相距为n的字母相同。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e6+10; char s[N]; bool ok(int n) &#123; if(n%2)return 0; n/=2; for(int i=0;i&lt;n;++i) if(s[i]!=s[i+n])return 0; return 1; &#125; int main() &#123; scanf(\"%s\",s); int len=strlen(s); puts(ok(len)?\"YES\":\"NO\"); return 0; &#125; H. 自定义排序 按题意排序，使用一种\\(O(nlogn)\\)的排序方式即可通过，或使用STL。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+5; int n,oa,ob,oc; struct node &#123; int a,b,c; &#125;e[N]; bool operator&lt;(node x,node y) &#123; if(x.a!=y.a)return oa?x.a&lt; y.a:x.a&gt;y.a; if(x.b!=y.b)return ob?x.b&lt; y.b:x.b&gt;y.b; if(x.c!=y.c)return oc?x.c&lt; y.c:x.c&gt;y.c; &#125; int main() &#123; scanf(\"%d%d%d%d\",&amp;n,&amp;oa,&amp;ob,&amp;oc); for(int i=0;i&lt;n;++i) scanf(\"%d%d%d\",&amp;e[i].a,&amp;e[i].b,&amp;e[i].c); sort(e,e+n); for(int i=0;i&lt;n;++i) printf(\"%d %d %d\\n\",e[i].a,e[i].b,e[i].c); return 0; &#125; D. 爱在公元前 考虑一个月日只可能对应一个年，且9220年02月29日合法，所以先将366个合法日期处理出来。 对于每个询问日期tmp，暴力判断366个日期哪个小于等于tmp即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int t,dat[]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;; int cnt,y,m,d; char s[10]; struct node &#123; int y,m,d; &#125;e[367],tmp; bool cmp(node a,node b) &#123; if(a.y!=b.y)return a.y&lt;b.y; if(a.m!=b.m)return a.m&lt;b.m; if(a.d!=b.d)return a.d&lt;b.d; return 1; &#125; bool leap(int x) &#123; if(x%400==0||(x%100 &amp;&amp; x%4==0))return 1; return 0; &#125; void init() &#123; int y; for(int i=1;i&lt;=12;++i) &#123; for(int j=1;j&lt;=31;++j) &#123; if(j&gt;dat[i])break; y=i/10+(i%10)*10+(j/10)*100+(j%10)*1000; if(!leap(y) &amp;&amp; (i==2&amp;&amp;j==29))break; e[++cnt]=node&#123;y,i,j&#125;; &#125; &#125; &#125; int main() &#123; scanf(\"%d\",&amp;t); init(); while(t--) &#123; scanf(\"%s\",s); y=m=d=0; for(int i=0;i&lt;4;++i) y=y*10+(s[i]-'0'); for(int i=4;i&lt;6;++i) m=m*10+(s[i]-'0'); for(int i=6;i&lt;8;++i) d=d*10+(s[i]-'0'); tmp=node&#123;y,m,d&#125;; int ans=0; for(int i=1;i&lt;=cnt;++i) if(cmp(e[i],tmp))ans++; printf(\"%d\\n\",ans); &#125; return 0; &#125; I. OJ的反作弊系统 按题意二分，二分的位置越界即答案不存在，或使用STL。 小于等于v的最大位置即大于v的最小位置-1。 同理，小于v的最大位置即大于等于v的最小位置-1。 //手写二分 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+10; int n,m,v,x[N],pos,ans; char s[5]; int upper(int l,int r,int v) &#123; int mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(x[mid]&lt;=v)l=mid+1; else r=mid-1; &#125; return l; &#125; int lower(int l,int r,int v) &#123; int mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(x[mid]&lt;v)l=mid+1; else r=mid-1; &#125; return l; &#125; int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;x[i]); sort(x+1,x+n+1); for(int i=1;i&lt;=m;++i) &#123; scanf(\"%s%d\",s,&amp;v); char op=s[0]; if(op=='A') &#123; pos=upper(1,n,v); if(pos&gt;n)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='B') &#123; pos=lower(1,n,v); pos--; if(pos&lt;1)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='C') &#123; pos=lower(1,n,v); if(pos&gt;n)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='D') &#123; pos=upper(1,n,v); pos--; if(pos&lt;1)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; &#125; return 0; &#125; //STL #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+10; int n,m,v,x[N],pos,ans; char s[5]; int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;x[i]); sort(x+1,x+n+1); for(int i=1;i&lt;=m;++i) &#123; scanf(\"%s%d\",s,&amp;v); char op=s[0]; if(op=='A') &#123; pos=upper_bound(x+1,x+n+1,v)-x; if(pos&gt;n)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='B') &#123; pos=lower_bound(x+1,x+n+1,v)-x; pos--; if(pos&lt;1)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='C') &#123; pos=lower_bound(x+1,x+n+1,v)-x; if(pos&gt;n)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; else if(op=='D') &#123; pos=upper_bound(x+1,x+n+1,v)-x; pos--; if(pos&lt;1)puts(\"-1\"); else printf(\"%d\\n\",pos); &#125; &#125; return 0; &#125; C. 耀宗学长的图像处理课本 原题题号UVA297，开始出了\\(dep&gt;5\\)的数据，向被卡这道题的参赛选手抱歉。 做法较多，可以根据实际矩形递归建树，也可以只利用树形递归建树，先序遍历这棵树。 遇见字母\\(p\\)就向下递归4个位置，遇到字母\\(f\\)就统计答案。 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int len = 32; const int maxn = 1024 + 10; char s[maxn]; int buf[len][len], cnt; void draw(const char *s, int &amp;p, int r, int c, int w) &#123; char ch = s[p++]; if (ch == 'p') &#123; draw(s, p, r, c + w / 2, w / 2); draw(s, p, r, c, w / 2); draw(s, p, r + w / 2, c, w / 2); draw(s, p, r + w / 2, c + w / 2, w / 2); &#125; else if (ch == 'f') &#123; for (int i = r; i &lt; r + w; i++) for (int j = c; j &lt; c + w; j++) if (buf[i][j] == 0) &#123; buf[i][j] = 1; cnt++; &#125; &#125; &#125; int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; memset(buf, 0, sizeof(buf)); cnt = 0; for (int i = 0; i &lt; 2; i++) &#123; scanf(\"%s\", s); int p = 0; draw(s, p, 0, 0, len); &#125; printf(\"There are %d black pixels.\\n\", cnt); &#125; return 0; &#125; K. 取模运算 分块，优雅的暴力。 考虑最暴力的回答2询问的方式，\\(tong[x]\\)代表\\(x\\)的值的个数，遍历\\(x, x+p, x+2p, ...,\\)直至上限\\({10}^{5}\\)，累加\\(tong\\)的值，所需次数大致为\\(\\frac{ {10}^{5}}{p}\\)。 对于\\(p\\geq \\sqrt{ {10}^{5}}\\)的询问，单次所需次数不超过\\(\\sqrt{ {10}^{5}}\\)，可以接受。 对于\\(p&lt;\\sqrt{ {10}^{5}}\\)的询问，暴力显然超时，开二维数组预存所有\\(p&lt; \\sqrt{ {10}^{5}}\\)的答案，now[p][x]代表\\(\\%p ==x\\)的值的个数\\((p&lt;\\sqrt{ {10}^{5}},x&lt;p )\\). 针对每次单点修改，及时更新tong和now数组的值。 针对每次询问，若\\(p\\geq \\sqrt{ {10}^{5}}\\)，暴力统计，否则直接回答now[][x]的值。 复杂度为\\(O(n\\sqrt{n})\\)。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+10; const int M=sqrt(N)+5; int n,m,op,x,y,a[N],ans; int now[M][M],tong[N]; int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); int sq=sqrt(N); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%d\",&amp;a[i]); tong[a[i]]++; for(int j=1;j&lt;=sq;++j) now[j][a[i]%j]++; &#125; while(m--) &#123; scanf(\"%d%d%d\",&amp;op,&amp;x,&amp;y); if(op==1) &#123; for(int j=1;j&lt;=sq;++j) &#123; now[j][a[x]%j]--; now[j][y%j]++; &#125; tong[a[x]]--; tong[y]++; a[x]=y; &#125; else if(op==2) &#123; if(x&gt;=y)ans=0; else &#123; if(y&lt;=sq)ans=now[y][x]; else &#123; ans=0; for(int i=x;i&lt;N;i+=y) ans+=tong[i]; &#125; &#125; printf(\"%d\\n\",ans); &#125; &#125; return 0; &#125; F. 菜鸟工程师的分子划分 题意： 平面上有n个点，不是白点就是黑点。现在要放一条直线，使得直线一侧的白点与另一侧的黑点加起来数目最多。直线上的点可以看作位于直线的任意一侧。 思路： 首先假设直线经过两个点，否则可以移动直线使其经过两个点，并且总数不会减少。 所以，我们可以先枚举一个基点，然后以这个点为中心。 围绕基点将其他点按照极角排序，将直线旋转，统计符合要求的点的个数。 需要注意的是，如果将所有的黑点以基点为中心做一个中心对称，则符合要求的点的个数就变成了直线一侧的点的个数。 #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int maxn = 1000 + 5; struct Point &#123; int x, y; double rad; // with respect to current point bool operator&lt;(const Point &amp;rhs) const &#123; return rad &lt; rhs.rad; &#125; &#125; op[maxn], p[maxn]; int n, color[maxn]; // from O-A to O-B, is it a left turn? bool Left(Point A, Point B) &#123; return A.x * B.y - A.y * B.x &gt;= 0; &#125; int solve() &#123; if(n &lt;= 2) return 2; int ans = 0; // pivot point for(int i = 0; i &lt; n; i++)&#123; int k = 0; // the list of other point, sorted in increasing order of rad for(int j = 0; j &lt; n; j++) if(j != i)&#123; p[k].x = op[j].x - op[i].x; p[k].y = op[j].y - op[i].y; if(color[j])&#123; p[k].x = -p[k].x; p[k].y = -p[k].y; &#125; p[k].rad = atan2(p[k].y, p[k].x); k++; &#125; sort(p, p+k); // sweeping. cnt is the number of points whose rad is between p[L] and p[R] int L = 0, R = 0, cnt = 2;//consider the position of \"cnt--\" while(L &lt; k)&#123; if(R == L)&#123; R = (R+1)%k; // empty interval cnt++; &#125; while(R != L &amp;&amp; Left(p[L], p[R]))&#123; R = (R+1)%k; // stop when [L,R] spans across &gt; 180 degrees cnt++; &#125; cnt--; L++; ans = max(ans, cnt); &#125; &#125; return ans; &#125; int main() &#123; while(scanf(\"%d\",&amp;n)==1&amp;&amp;n)&#123; for(int i = 0; i &lt; n; i++) scanf(\"%d%d%d\", &amp;op[i].x, &amp;op[i].y, &amp;color[i]); printf(\"%d\\n\", solve()); &#125; return 0; &#125; L. 七星堆六朝墓群 求最大同色子矩阵，可采用悬线法或单调栈。h[j]代表当前相同值的高度，L[j]代表以h[j]的高度能移动到的最左位置，R[j]代表以h[j]的高度能移动到的最右位置，则当前枚举的等高子矩阵的面积为\\((R[j]-L[j]+1)*h[j]\\)。 ①单调栈 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e3+10; typedef long long ll; int n,m,a[N][N],h[N],L[N],R[N]; int stk,q[N]; ll ans; int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; if(a[i][j]==a[i-1][j])h[j]++; else h[j]=1; &#125; int l,r; for(l=1;l&lt;=n;l=r+1) &#123; r=l; while(r&lt;=n&amp;&amp;a[i][l]==a[i][r])r++; r--; stk=0; for(int k=l;k&lt;=r;++k) &#123; while(stk&amp;&amp;h[q[stk]]&gt;=h[k])stk--; if(!stk)L[k]=l; else L[k]=q[stk]+1; q[++stk]=k; &#125; stk=0; for(int k=r;k&gt;=l;--k) &#123; while(stk&amp;&amp;h[q[stk]]&gt;=h[k])stk--; if(!stk)R[k]=r; else R[k]=q[stk]-1; q[++stk]=k; &#125; for(int k=l;k&lt;=r;++k) &#123; ans=max(ans,1ll*(R[k]-L[k]+1)*h[k]*a[i][k]); &#125; &#125; &#125; printf(\"%lld\\n\",ans); return 0; &#125; ②悬线法 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int N=2e3+10; typedef long long ll; int m,n,a[N][N]; int l[N],r[N],h[N]; int main() &#123; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; for(int j=1;j&lt;=m;j++) l[j]=0,r[j]=m+1,h[j]=0; ll ans=0; int la,ra; for(int i=1;i&lt;=n;++i) &#123; la=0;ra=m+1; for(int j=1;j&lt;=m;++j) &#123; if(a[i][j]==a[i-1][j]) h[j]++; else h[j]=1,l[j]=0,r[j]=m+1; if(a[i][j]==a[i][j-1]) l[j]=max(l[j],la+1); else l[j]=j,la=j-1; &#125; for(int j=m;j&gt;=1;--j) &#123; if(a[i][j]==a[i][j+1]) r[j]=min(r[j],ra-1); else r[j]=j,ra=j+1; ans=max(ans,1ll*h[j]*(r[j]-l[j]+1)*a[i][j]); &#125; &#125; printf(\"%lld\\n\",ans); &#125; return 0; &#125; B. 立方和 线段树经典题目，hdu4578的弱化版本。 首先考虑加与乘。 用add来表示区间内每个数通过加法操作所增加的值(就是说先加a再乘b再加c之后，这里存的数是a*b+c); 用mult来表示区间内每个数被乘以后的倍数（注意默认应当为1）。 然后再考虑立方和，在这里只解释一下平方和怎么维护，立方和原理类似。（代码中的实现为函数up） 例如，我要把区间\\([L,R]\\)内每个数的值从\\(x_i\\)变为\\(x_i+p\\)的话,那么区间内每个数的变化量为\\((x_i+p)^2-x_i^2=2x_ip+p^2\\),区间平方和\\(mk[2]\\)的变化量为\\(2*mk[1]*p+(R-L+1)*p^2\\).那么只需要通过加一个数就可以维护区间平方和了。 需要注意的是，由于这里使用的\\(mk[1]\\)应当是这段区间发生区间加以前的，因而在更新是应该先更新\\(mk[2]\\)再更新\\(mk[1]\\)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int mod = 1e4 + 7; const int N = 1e5 + 10; struct node &#123; int l, r; int p[4]; int addlazy, multlazy; &#125; tree[N &lt;&lt; 2]; int a[N]; int mk[4]; void up(int pos, int op) &#123; int len = tree[pos].r - tree[pos].l + 1; if (op == 3) &#123; tree[pos].p[3] += 1ll * mk[3] * len % mod + 3ll * mk[2] * tree[pos].p[1] % mod + 3ll * mk[1] * tree[pos].p[2] % mod; tree[pos].p[3] %= mod; &#125; if (op == 2) &#123; tree[pos].p[2] += 1ll * mk[2] * len % mod + 2ll * mk[1] * tree[pos].p[1] % mod; tree[pos].p[2] %= mod; &#125; if (op == 1) &#123; tree[pos].p[1] += 1ll * mk[1] * len % mod; tree[pos].p[1] %= mod; &#125; &#125; void pushdown(int pos) &#123; if (tree[pos].multlazy != 1) &#123; int w = tree[pos].multlazy; mk[0] = 1; for (int i = 1; i &lt;= 3; i++) mk[i] = 1ll * w * mk[i - 1] % mod; tree[pos * 2].multlazy = 1ll * tree[pos * 2].multlazy * mk[1] % mod; tree[pos * 2 + 1].multlazy = 1ll * tree[pos * 2 + 1].multlazy * mk[1] % mod; tree[pos * 2].addlazy = 1ll * tree[pos * 2].addlazy * mk[1] % mod; tree[pos * 2 + 1].addlazy = 1ll * tree[pos * 2 + 1].addlazy * mk[1] % mod; for (int i = 1; i &lt;= 3; i++) &#123; tree[pos * 2].p[i] = 1ll * tree[pos * 2].p[i] * mk[i] % mod; tree[pos * 2 + 1].p[i] = 1ll * tree[pos * 2 + 1].p[i] * mk[i] % mod; &#125; tree[pos].multlazy = 1; &#125; if (tree[pos].addlazy != 0) &#123; int w = tree[pos].addlazy; mk[0] = 1; for (int i = 1; i &lt;= 3; i++) mk[i] = 1ll * w * mk[i - 1] % mod; tree[pos * 2].addlazy += w, tree[pos * 2].addlazy %= mod; tree[pos * 2 + 1].addlazy += w, tree[pos * 2 + 1].addlazy %= mod; up(pos * 2, 3); up(pos * 2 + 1, 3); up(pos * 2, 2); up(pos * 2 + 1, 2); up(pos * 2, 1); up(pos * 2 + 1, 1); tree[pos].addlazy = 0; &#125; &#125; void pushup(int pos) &#123; for (int i = 1; i &lt;= 3; i++) tree[pos].p[i] = (tree[pos * 2 + 1].p[i] + tree[pos * 2].p[i]) % mod; &#125; void build(int pos, int l, int r) &#123; tree[pos].l = l; tree[pos].r = r; tree[pos].multlazy = 1; if (l == r) &#123; tree[pos].p[1] = a[l] % mod; tree[pos].p[2] = a[l] * a[l] % mod; tree[pos].p[3] = 1ll * a[l] * a[l] * a[l] % mod; return; &#125; int mid = (tree[pos].l + tree[pos].r) &gt;&gt; 1; build(pos * 2, l, mid); build(pos * 2 + 1, mid + 1, r); pushup(pos); &#125; void update(int pos, int l, int r, int w, int op) &#123; if (l &lt;= tree[pos].l &amp;&amp; tree[pos].r &lt;= r) &#123; mk[0] = 1; for (int i = 1; i &lt;= 3; i++) mk[i] = 1ll * w * mk[i - 1] % mod; if (op == 1) &#123; tree[pos].addlazy += w; tree[pos].addlazy %= mod; up(pos, 3); up(pos, 2); up(pos, 1); &#125; else &#123; tree[pos].multlazy = 1ll * w * tree[pos].multlazy % mod; tree[pos].addlazy = 1ll * w * tree[pos].addlazy % mod; for (int i = 1; i &lt;= 3; i++) tree[pos].p[i] = 1ll * tree[pos].p[i] * mk[i] % mod; &#125; return; &#125; pushdown(pos); int mid = (tree[pos].l + tree[pos].r) &gt;&gt; 1; if (l &lt;= mid) update(pos * 2, l, r, w, op); if (r &gt; mid) update(pos * 2 + 1, l, r, w, op); pushup(pos); &#125; int quary(int pos, int l, int r) &#123; if (l &lt;= tree[pos].l &amp;&amp; tree[pos].r &lt;= r) &#123; return tree[pos].p[3] % mod; &#125; pushdown(pos); int mid = (tree[pos].l + tree[pos].r) &gt;&gt; 1; int res = 0; if (l &lt;= mid) res += quary(pos * 2, l, r); res %= mod; if (r &gt; mid) res += quary(pos * 2 + 1, l, r); return res % mod; &#125; int n, m; int main() &#123; #ifdef ONLINE_JUDGE #else freopen(\"r.txt\", \"r\", stdin); #endif scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); build(1, 1, n); //cout&lt;&lt;tree[1].p[1]&lt;&lt;endl; for (int i = 1; i &lt;= m; i++) &#123; int ff, x, y, w; scanf(\"%d%d%d\", &amp;ff, &amp;x, &amp;y); if (ff == 1) &#123; scanf(\"%d\", &amp;w); update(1, x, y, w, 1); &#125; else if (ff == 2) &#123; scanf(\"%d\", &amp;w); update(1, x, y, w, 2); &#125; else &#123; printf(\"%d\\n\", quary(1, x, y)); &#125; &#125; &#125; G. 牙签自动机 ①暴力 把一根木棍分为4等分，然后在1/4与3/4的位置做标记，表示这里有一根木棍。然后每次判断标记点的边上能不能放一根木棍。奇数轮，只能横着摆；偶数轮，只能竖着摆。比如在判断\\([i,j]\\)点的左侧能不能摆棒子的时候，判断\\([i-1,j-1],[i-1,j+1],[i-2,j]\\)是否被标记（多判一个点的原因是，注意第三轮，两根横棒中间没有生成竖棒），如果都没有，那么可以在\\([i-1,j-2]\\)~\\([i-1,j+2]\\)间摆一根棒子，并标记\\([i-1,j-1],[i-1,j+1]\\). 例如，开始的一根摆在了\\([1998,2000]\\)~\\([2002,2000]\\)，然后标记\\([1999,2000],[2001,2000]\\),判断\\([1998,1999],[1998,2001],[1997,2000]\\)都没有被标记，那么可以在左边放竖棒，并标记\\([1998,1999],[1998,2001]\\). 程序中使用了队列来确定这到底是第几轮。 #include&lt;bits/stdc++.h&gt; using namespace std; int ans[1050],mp[4000][4000]; queue&lt;pair&lt;int,int&gt; &gt; q; inline int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x; &#125; inline void init() &#123; int p=0,num=1,tot=1; ans[1]=1; mp[1999][2000]=1; mp[2001][2000]=1; q.push(make_pair&lt;int,int&gt;(1999,2000)); q.push(make_pair&lt;int,int&gt;(2001,2000)); q.push(make_pair&lt;int,int&gt;(0,0)); while(num&lt;1030) &#123; ++num; while(1) &#123; int le=q.front().first,ri=q.front().second; q.pop(); if(le==0&amp;&amp;ri==0) break; if(!p&amp;&amp;!mp[le-1][ri-1]&amp;&amp;!mp[le-1][ri+1]&amp;&amp;!mp[le-2][ri]) &#123; ++tot; mp[le-1][ri-1]=mp[le-1][ri+1]=1; q.push(make_pair&lt;int,int&gt;(le-1,ri-1)); q.push(make_pair&lt;int,int&gt;(le-1,ri+1)); continue; &#125; if(!p&amp;&amp;!mp[le+1][ri-1]&amp;&amp;!mp[le+1][ri+1]&amp;&amp;!mp[le+2][ri]) &#123; ++tot; mp[le+1][ri-1]=mp[le+1][ri+1]=1; q.push(make_pair&lt;int,int&gt;(le+1,ri-1)); q.push(make_pair&lt;int,int&gt;(le+1,ri+1)); continue; &#125; if(p&amp;&amp;!mp[le-1][ri-1]&amp;&amp;!mp[le+1][ri-1]&amp;&amp;!mp[le][ri-2]) &#123; ++tot; mp[le-1][ri-1]=mp[le+1][ri-1]=1; q.push(make_pair&lt;int,int&gt;(le-1,ri-1)); q.push(make_pair&lt;int,int&gt;(le+1,ri-1)); continue; &#125; if(p&amp;&amp;!mp[le-1][ri+1]&amp;&amp;!mp[le+1][ri+1]&amp;&amp;!mp[le][ri+2]) &#123; ++tot; mp[le-1][ri+1]=mp[le+1][ri+1]=1; q.push(make_pair&lt;int,int&gt;(le-1,ri+1)); q.push(make_pair&lt;int,int&gt;(le+1,ri+1)); continue; &#125; &#125; ans[num]=tot; q.push(make_pair&lt;int,int&gt;(0,0)); p^=1; &#125; &#125; int main()&#123; init(); int n=read(); while(n--) &#123; int now=read(); printf(\"%d%c\",ans[now],n?' ':'\\n'); &#125; &#125; ②本地模拟直接交打表后的值 将打表后的值放入mp[1030]，每次直接查询mp[i].代码仅11MB ③找规律 我们针对每个图形的右上角进行分析可以发现：每一次非2的次方的数字时，右上角模块总可以被划分成三个部分，即sto[m]*2和sto[m+1]；同时，每一次为2的次方的时候，整个图形为一个外边封闭近似正方形，其内部为\\(2^{2*k+1}+1\\)个牙签。 因此，图形的表达式为： \\[\\left\\{\\begin{matrix} n=2^k &amp; sto[n] = 2^{(2k+1)}/3\\\\ n\\neq 2^k &amp; sto[n] = 2^{k} + sto[n - 2^{k}] * 2 + sto[n - 2^{k}+1] -1 \\end{matrix}\\right.\\] #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; typedef long long ll; ll sto[1025], base[35] = &#123;1ll&#125;; inline ll read() &#123; ll X = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123; w |= ch == '-'; ch = getchar(); &#125; while (isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w ? -X : X; &#125; inline void write(int x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; inline void writesp(int x) &#123; write(x); putchar(' '); &#125; int main() &#123; for (int i = 1; i &lt;= 30; i++) base[i] = base[i - 1] &lt;&lt; 1ll; for (int i = 0; i &lt;= 1024; i++) &#123; int k = lower_bound(base, base + 15, i) - base; if (base[k] == i) sto[i] = (base[2 * k + 1] + 1) / 3; else &#123; k--; int m = i - base[k]; sto[i] = sto[base[k]] + 2ll * sto[m] + sto[m + 1] - 1ll; &#125; &#125; sto[0] = 0; int T = read(); for (int i = 0; i &lt; T; i++) &#123; if (i) putchar(' '); write(sto[read()]); &#125; return 0; &#125; E. 膜法项链 Easy Version \\(n\\leq2000\\) 从0到n-1枚举第二种操作的使用次数step， 那么对于最终得到的编号为i的珍珠， 假如它是召放在j位置然后右移多次得到的， 则一定有 \\(i-step\\leq j \\leq i\\) ， 并且这是充要的，即它可以由这个区间的任何一个j生成后右移多次得到。 因此只用这个区间的a[j]的最小值就是得到i的代价。 把所有i的代价相加再加上step*x就是step对应的最小代价。 注意，这个题目是一个环而不是链，这只需要将a复制一份即可。 求区间最小值有很多方法，比如单调队列。 时间复杂度 \\(O(n^2)\\) 戳我补题 E. 膜法项链 Hard Version 时间复杂度\\(O(n)\\) #include&lt;bits/stdc++.h&gt; using namespace std; int n;long long w; long long d[2000100]; long long a[2000100]; long long st[2000200]; int num[2000200]; int se=0; int main()&#123; scanf(\"%d%lld\",&amp;n,&amp;w); for(int i=0;i&lt;n;i++)&#123; scanf(\"%lld\",&amp;a[i]); a[i+n]=a[i]; &#125; a[2*n]=-1; for(int i=0;i&lt;=2*n;i++)&#123; if(se==0||st[se-1]&lt;=a[i])&#123; st[se]=a[i]; num[se]=i; se++; &#125; else&#123; while(se&amp;&amp;st[se-1]&gt;a[i])&#123; if(i&gt;n)&#123; int d2begin=max(num[se-1],n); int d2len=i-d2begin; int dbegin;int dlen; if(se==1)&#123; dbegin=0; &#125; else&#123; dbegin=num[se-2]; &#125; dlen=num[se-1]-dbegin; d[d2begin-num[se-1]]+=st[se-1];d[d2begin-num[se-1]+d2len]-=st[se-1]; d[d2begin-num[se-1]+dlen]-=st[se-1];d[d2begin-num[se-1]+dlen+d2len]+=st[se-1]; &#125; se--; &#125; st[se]=a[i]; num[se]=i; se++; &#125; &#125; for(int i=1;i&lt;=2*n;i++)&#123; d[i]=d[i-1]+d[i]; &#125; for(int i=1;i&lt;=2*n;i++)&#123; d[i]=d[i-1]+d[i]; &#125; long long ans=0x3f3f3f3f3f3f3f3f; for(int i=0;i&lt;n;i++)&#123; ans=min(ans,i*w+d[i]); &#125; printf(\"%lld\\n\",ans); &#125; J. 更强的未来道具FG-C193 Easy Version 以每个为止判断每个对称轴会对称到哪一个位置。最后查看所有位置是否相同。 复杂度\\(O(n^2)\\) 戳我补题 J. 更强的未来道具FG-C193 Hard Version 像manacher一样两字符中间补一个字符。然后对manacher判断的位置进行判断，不过把判断两字符是否相同改为将带权并查集合并。 复杂度\\(O(n)\\) #include&lt;bits/stdc++.h&gt; using namespace std; int a[200040]; int abc[220000]; int abcpos[220000]; int fa[200040]; int ans[200040]; int unans[200020]; int aans[100020]; int find(int i)&#123; if(fa[i]!=i)&#123; fa[i]=find(fa[i]); ans[i]=ans[fa[i]]; return fa[i]; &#125; return fa[i]; &#125; int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;2*n;i++)&#123; scanf(\"%d\",&amp;a[i]); a[i]*=2; &#125; for(int i=0;i&lt;=2*n;i++)&#123; fa[i]=i; &#125; int m; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++)&#123; int tmp; scanf(\"%d\",&amp;tmp); char tchar; scanf(\" %c\",&amp;tchar); if(aans[tmp]&amp;&amp;aans[tmp]!=tchar)&#123; printf(\"-1\\n\");return 0; &#125; aans[tmp]=tchar; if(abc[tchar]!=0)&#123; find(2*tmp); find(abcpos[tchar]); fa[find(2*tmp)]=find(abcpos[tchar]); &#125; ans[2*tmp]=tchar; abc[tchar]++;abcpos[tchar]=tmp*2; &#125; for(int i=1;i&lt;=n;i++)&#123; fa[i*2-1]=1; ans[i*2-1]=257; &#125; int nowmax=0; for(int i=0;i&lt;2*n;i++)&#123; while(nowmax&lt;=a[i]+i-1)&#123; if(nowmax&lt;2*n&amp;&amp;(i-nowmax+i)&gt;=0)&#123; if(find(i-nowmax+i)!=find(nowmax))&#123; if(ans[find(i-nowmax+i)]&amp;&amp;ans[find(nowmax)]&amp;&amp;ans[find(i-nowmax+i)]!=ans[find(nowmax)])&#123; printf(\"-1\\n\"); return 0; &#125; else&#123; if(ans[find(nowmax)]==0) &#123; fa[find(nowmax)]=find(i-nowmax+i);find(nowmax); &#125; else&#123; fa[find(i-nowmax+i)]=find(nowmax); find(i-nowmax+i); &#125; &#125; &#125; &#125; nowmax++; &#125; &#125; for(int i=0;i&lt;2*n;i++)&#123; if(i+a[i]&lt;2*n&amp;&amp;i-a[i]&gt;=0&amp;&amp;(i-a[i])%2==0)&#123; if(find(i-a[i])==find(i+a[i]))&#123; printf(\"-1\\n\"); return 0; &#125; &#125; if(i+a[i]+1&lt;2*n&amp;&amp;i-a[i]-1&gt;=0&amp;&amp;(i-a[i])%2!=0)&#123; if(find(i-a[i]-1)==find(i+a[i]+1))&#123; printf(\"-1\\n\"); return 0; &#125; &#125; &#125; int unknow=0; for(int i=0;i&lt;n;i++)&#123; if(ans[find(2*i)]==0)&#123; unans[unknow]=i; unknow++; &#125; &#125; if(unknow)&#123; for(int i=0;i&lt;unknow;i++)&#123; if(i!=0) printf(\" \"); printf(\"%d\",unans[i]); &#125; printf(\"\\n\"); &#125; else&#123; for(int i=0;i&lt;n;i++)&#123; printf(\"%c\",ans[find(2*i)]); &#125; printf(\"\\n\"); &#125; &#125;","permalink":"http://sher-wu.github.io/2019/12/11/%E5%8D%8E%E4%B8%BA%E6%9D%AF-%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AC%AC12%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E9%A2%98%E8%A7%A3/","photos":[]},{"tags":[{"name":"树上差分","slug":"树上差分","permalink":"http://sher-wu.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"}],"title":"P3128","date":"2019/12/10","text":"P3128 [USACO15DEC] 最大流 Description Farmer John给他的牛棚的 \\(N(2\\leq N\\leq50,000)\\) 个隔间之间安装了\\(N-1\\)根管道，隔间编号从\\(1\\)到\\(N\\)。所有隔间都被管道连通了。 FJ有\\(K(1\\leq K\\leq100,000)\\)条运输牛奶的路线，第i条路线从隔间\\(s_i\\)运输到隔间\\(t_i\\)。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 Input The first line of the input contains N and K. The next N-1 lines each contain two integers x and y (\\(x \\neq y\\)) describing a pipe between stalls x and y. The next K lines each contain two integers s and t describing the endpoint stalls of a path through which milk is being pumped. Output An integer specifying the maximum amount of milk pumped through any stall in the barn. Sample Input 5 10 3 4 1 5 4 2 5 4 5 4 5 4 3 5 4 3 4 3 1 3 3 5 5 4 1 5 3 4 Sample Output 9 思路： N个节点构成了一棵树，然后在树上的边有流量，给定一条路线，其所经过的边流量都+1. 典型的含边权的树上差分。根据树上差分思想，把边的流量保存在儿子节点上，当从u到v有一条路线时，只跟u到v上所有的边有关系，而跟lca(u,v)到根的边全都无关。因而flow[u]++,flow[v]++,flow[lca(u,v)]-=2. 全部加完后，用一次DFS即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 5e4+20; int n,k; int bei[22],f[maxn],high,tot[maxn];//flow int d[maxn],fir[maxn],nex[2*maxn],to[2*maxn]; int fa[maxn][22]; inline ll read()&#123; ll x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x; &#125; inline void dfs1(int now,int pre,int depth)//init for lca &#123; d[now]=depth; fa[now][0]=pre; for(int i=1;i&lt;=20;++i) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=fir[now];i;i=nex[i]) &#123; if(to[i]==pre) continue; dfs1(to[i],now,depth+1); &#125; &#125; inline int lca(int x,int y) &#123; if(d[x]&lt;d[y]) swap(x,y); for(int i=20;i&gt;=0;--i) if(d[x]-bei[i]&gt;=d[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125; inline void dfs2(int x,int y)//add values &#123; int l=lca(x,y); ++f[x],++f[y],--f[l],--f[fa[l][0]]; &#125; inline void dfs3(int now,int pre)//find the point with highest value &#123; for(int p=fir[now];p;p=nex[p]) &#123; if(to[p]==pre) continue; dfs3(to[p],now); tot[now]+=tot[to[p]]; &#125; tot[now]+=f[now]; if(tot[now]&gt;high) high=tot[now]; &#125; int main() &#123; n=read(),k=read(); bei[0]=1; for(int i=1;i&lt;=20;++i) bei[i]=bei[i-1]*2; for(int i=1;i&lt;n;++i) &#123; int p=read(),q=read(); nex[i]=fir[p],fir[p]=i,to[i]=q; nex[n+i]=fir[q],fir[q]=n+i,to[n+i]=p; &#125; dfs1(1,0,1); while(k--) dfs2(read(),read()); dfs3(1,0); printf(\"%d\\n\",high); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/12/10/P3128/","photos":[]},{"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"http://sher-wu.github.io/tags/%E6%A0%88/"}],"title":"BZOJ4756","date":"2019/12/06","text":"BZOJ4756 [Usaco2017 Jan] Promotion Counting Description n只奶牛构成了一个树形的公司，每个奶牛有一个能力值pi，1号奶牛为树根。 问对于每个奶牛来说，它的子树中有几个能力值比它大的。 Input n，表示有几只奶牛 n&lt;=100000 接下来n行为1-n号奶牛的能力值pi 接下来n-1行为2-n号奶牛的经理（树中的父亲） Output 共n行，每行输出奶牛i的下属中有几个能力值比i大 Sample Input 5 804289384 846930887 681692778 714636916 957747794 1 1 2 3 Sample Output 2 0 1 0 0 Solution 如果每个节点都给一个线段树，然后暴力的在父节点将两个线段树合并，那么空间肯定是不够的。因而首先要在空间上进行优化。这里引入了树上的线段树合并。 \"树上\"还是原来的，DFS的顺序从下往上维护。 \"线段树合并\"的步骤如下（这里的线段树实际上是一个链）： 对于两颗树的节点u和v ①如果u为空，返回v ②如果v为空，返回u ③否则，新建节点t，整合u和v的信息，然后递归合并u和v的左右子树 inline int merge(int u,int v) &#123; if(!u) return v; if(!v) return u; int t = ++cnt; sum[t]=sum[u]+sum[v]; les[t]=merge(les[u],les[v]); ris[t]=merge(ris[u],ris[v]); return t; &#125; 思考可知，每有一个位置权值同样存在，就要\\(O(logn)\\)的复杂度。那么合并的复杂度取决于两棵线段树重合部分的大小。 由于权值线段树中被更新的位置通常很均匀分布，所以合并的两棵线段树通常具有很小的相似性。 线段树合并的空间复杂度和时间复杂度都是\\(O(nlogn)\\)的。 （点大概要开\\(2nlogn\\)个，测了一下\\(n=131072\\)‬的时候\\(32n\\)，\\(n=524288\\)的时候\\(36n\\)‬，那么\\(2e7\\)个应该是肯定够的） 后来看了网上的博客，发现其实这题有更简单的做法。。。 按DFS序把所有点放入并取出一个栈，放入时计算小于\\(a_i\\)的数量并把\\(a_i\\)放入线段树中，取出时再计算一次小于\\(a_i\\)的数量，那么两者之差就是答案。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5+20; const int maxm = 2e7+20; int n,id[maxn],a[maxn],b[maxn],fa[maxn],ans[maxn]; int cnt,pid[maxn],sum[maxm],les[maxm],ris[maxm]; vector&lt;int&gt; son[maxn]; inline ll read()&#123; ll x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x*f; &#125; inline void readin() &#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(),b[i]=a[i]; sort(b+1,b+1+n);//题目给定了能力值互异，故不用去重 for(int i=1;i&lt;=n;++i) id[i]=lower_bound(b+1,b+1+n,a[i])-b; for(int i=2;i&lt;=n;++i) fa[i]=read(),son[fa[i]].push_back(i); &#125; inline int query(int qid,int l,int r,int pos) &#123; if(!qid) return 0; if(l&gt;pos) return sum[qid]; int m=(l+r)&gt;&gt;1; if(m&gt;pos) return query(ris[qid],m+1,r,pos)+query(les[qid],l,m,pos); return query(ris[qid],m+1,r,pos); &#125; inline int merge(int u,int v)//the core &#123; if(!u) return v;//某个没有，就直接用另一个，儿子信息可以直接用，不需要更新 if(!v) return u; int t = ++cnt;//都有，就另建一个点记录合并后的信息 sum[t]=sum[u]+sum[v]; les[t]=merge(les[u],les[v]);//并且维护新节点的儿子信息 ris[t]=merge(ris[u],ris[v]); return t; &#125; inline void modify(int&amp; qid,int l,int r,int pos)//add the current point &#123; if(!qid) qid=++cnt; ++sum[qid]; if(l==r) return; int m=(l+r)&gt;&gt;1; if(m&gt;=pos) modify(les[qid],l,m,pos); else modify(ris[qid],m+1,r,pos); &#125; inline int dfs(int now) &#123; for(int i=0;i&lt;son[now].size();++i) &#123; dfs(son[now][i]); pid[now]=merge(pid[now],pid[son[now][i]]); &#125; ans[now]=query(pid[now],1,n,id[now]); modify(pid[now],1,n,id[now]);//add the current point &#125; int main() &#123; readin(); dfs(1); for(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/12/06/BZOJ4756/","photos":[]},{"tags":[{"name":"组合概率","slug":"组合概率","permalink":"http://sher-wu.github.io/tags/%E7%BB%84%E5%90%88%E6%A6%82%E7%8E%87/"}],"title":"UVA11637","date":"2019/11/28","text":"UVA11637 - Garbage Remembering Exam 题意： 大概意思是，有n个单词，分别打乱放在一个环形的，一个非环形里面，环形的两个单词距离为顺时针逆时针的最小值，非环形的就是位置的差的绝对值，如果有一对单词，在两个里面的距离都是不大于k，那么这单词为无效单词，问平均会出现多少个无效单词 &gt; 思路： 组合概率，假设在非环形形成了一个随机序列，那么我们给它标号1-n,如果我们能分别算出1-n的有效概率，那么就等于算出了无效概率，那么有效概率等于和它距离大于k的那些位置的所有单词拿出来，假设有x个，在环形序列中选一个位置放这个单词，然后它周围的2k的位置（因为是环形序列）要放入这些x个，就是x个选2k个放进去，再全排列，然后剩下n-2k-1个位置再全排列，然后总情况数为n的全排列，所以这样公式一组合起来就是nC(2k,x)2k!(n−2k−1)!/n!，化简一下公式得到x!(n−2k−1)!/(x−2k)!/(n−1)!，这个数值无法直接运算，然后观察能发现他的分子和分母可以合起来考虑变成乘除的项数相同，分子为(n−2k−1)∗(n−2k−2)∗...∗(x−2k+1)，分母为(n−1)∗(n−2)∗...∗(x+1)，那么就可以先递推预处理出一个p数组，p[x]就表示原公式解，那么整个答案为就是非环形序列每个位置的概率*1求出期望，然后累加求总和，最后再用n减去该值得到无效单词的期望。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; //转化计算式，变成多个x-i/n-i相乘（x指在非环中当前数在它k范围外数的个数），然后预处理 const int N = 100005; int n, k; double p[N]; void init(int n, int k) &#123; memset(p, 0, sizeof(p)); p[n - 1] = 1.0; for (int i = n - 1; i &gt; 2 * k; i--) &#123; p[i - 1] = p[i] * (i - 2 * k) * 1.0 / (i * 1.0) ; &#125; &#125; double solve(int n, int k) &#123; init(n, k); double ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x = max(i - k - 1, 0) + max(n - i - k, 0); ans += p[x]; &#125; return n - ans; &#125; int main() &#123; int cas = 0; while (~scanf(\"%d%d\", &amp;n, &amp;k) &amp;&amp; n || k) &#123; printf(\"Case %d: %.4lf\\n\", ++cas, solve(n, k)); &#125; return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/28/UVA11637/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ1070","date":"2019/11/27","text":"BZOJ1070 [SCOI2007] 修车 Description 同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input 第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。 第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。 Output 最小平均等待时间，答案精确到小数点后2位。 Sample Input 2 2 3 2 1 4 Sample Output 1.50 HINT 数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60),(1&lt;=T&lt;=1000) 思路： 对同一个技术人员，如果车i倒数第x个被修理，那么该车对总时间的贡献就是tix。每个技术人员都可以把任何一辆车倒数第1个修，第2个修...第n个修，那么他们对总时间分别有不同的贡献。 因而建图：s到所有车连flow=1,cost=0的边，车向每个技工的倒数第x个位置连flow=1,cost=tix的边，每个技工的每个位置向t连flow=1,cost=0的边。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2020; const int INF = 1e9+7; typedef long long ll; int le,ri,sp[12][70]; struct MCMF&#123; struct Edge&#123; int from,to,cap,cost; Edge()&#123;&#125; Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost)&#123;&#125; &#125;; int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn];//inqueue int d[maxn];//dis int p[maxn];//pre int a[maxn];//flow void init() &#123; for(int i=0;i&lt;=n;++i) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost) &#123; edges.push_back(Edge(from,to,cap,cost)); edges.push_back(Edge(to,from,0,-cost)); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BF(int&amp; flow,int&amp; cost) &#123; for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0; d[s]=0,inq[s]=1,p[s]=0,a[s]=INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); inq[u]=0; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;G[u].size()&lt;&lt;' '&lt;&lt;d[u]&lt;&lt;'\\n'; for(int i=0;i&lt;G[u].size();++i) &#123; Edge&amp; e=edges[G[u][i]]; if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost) &#123; d[e.to]=d[u]+e.cost; p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap); if(!inq[e.to]) &#123; Q.push(e.to); inq[e.to]=1; &#125; &#125; &#125; &#125; if(d[t]==INF) return false; flow+=a[t]; cost+=d[t]*a[t]; int u=t; while(u!=s) &#123; edges[p[u]].cap-=a[t]; edges[p[u]^1].cap+=a[t]; u=edges[p[u]].from; &#125; return true; &#125; int Mincost() &#123; int flow=0,cost=0; //cout&lt;&lt;m&lt;&lt;endl; while(BF(flow,cost)); //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl; return cost; &#125; &#125;NF; inline int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; //if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x; &#125; inline void readin() &#123; int temp; le=read(),ri=read(); NF.s=0; NF.n=NF.t=ri*(le+1)+1; for(int i=1;i&lt;=ri;++i) NF.AddEdge(0,i,1,0); for(int i=1;i&lt;=ri;++i) for(int j=1;j&lt;=le;++j) &#123; sp[j][i]=read(); for(int k=1;k&lt;=ri;++k) NF.AddEdge(i,j*ri+k,1,k*sp[j][i]); &#125; for(int i=ri+1;i&lt;NF.t;++i) NF.AddEdge(i,NF.t,1,0); &#125; int main() &#123; NF.init(); readin(); printf(\"%.2lf\",1.0*NF.Mincost()/ri); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/27/BZOJ1070/","photos":[]},{"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sher-wu.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://sher-wu.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}],"title":"BZOJ2879","date":"2019/11/26","text":"BZOJ2879 [NOI2012] 美食节 Description CZ市为了欢迎全国各地的同学，特地举办了一场盛大的美食节。作为一个喜欢尝鲜的美食客，小M自然不愿意错过这场盛宴。他很快就尝遍了美食节所有的美食。然而，尝鲜的欲望是难以满足的。尽管所有的菜品都很可口，厨师做菜的速度也很快，小M仍然觉得自己桌上没有已经摆在别人餐桌上的美食是一件无法忍受的事情。于是小M开始研究起了做菜顺序的问题，即安排一个做菜的顺序使得同学们的等待时间最短。小M发现，美食节共有n种不同的菜品。每次点餐，每个同学可以选择其中的一个菜品。总共有m个厨师来制作这些菜品。当所有的同学点餐结束后，菜品的制作任务就会分配给每个厨师。然后每个厨师就会同时开始做菜。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。此外，小M还发现了另一件有意思的事情: 虽然这m个厨师都会制作全部的n种菜品，但对于同一菜品，不同厨师的制作时间未必相同。他将菜品用1, 2, …, n依次编号，厨师用1, 2, …, m依次编号，将第j个厨师制作第i种菜品的时间记为 ti,j 。小M认为：每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。换句话说，如果一个同学点的菜是某个厨师做的第k道菜，则他的等待时间就是这个厨师制作前k道菜的时间之和。而总等待时间为所有同学的等待时间之和。现在，小M找到了所有同学的点菜信息: 有 pi 个同学点了第i种菜品（i=1, 2, …, n）。他想知道的是最小的总等待时间是多少。 Input 输入文件的第1行包含两个正整数n和m，表示菜品的种数和厨师的数量。 第2行包含n个正整数，其中第i个数为pi，表示点第i种菜品的人数。 接下来有n行，每行包含m个非负整数，这n行中的第i行的第j个数为ti,j，表示第j个厨师制作第i种菜品所需的时间。 输入文件中每行相邻的两个数之间均由一个空格隔开，行末均没有多余空格。 Output 输出仅一行包含一个整数，为总等待时间的最小值。 Sample Input 3 2 3 1 1 5 7 3 6 8 9 Sample Output 47 样例说明 厨师1先制作1份菜品2，再制作2份菜品1。点这3道菜的3个同学的等待时间分别为3，3+5=8，3+5+5=13。 厨师2先制作1份菜品1，再制作1份菜品3。点这2道菜的2个同学的等待时间分别为7，7+9=16。 总等待时间为3+8+13+7+16=47。 虽然菜品1和菜品3由厨师1制作更快，如果这些菜品都由厨师1制作，总等待时间反而更长。如果按上述的做法，将1份菜品1和1份菜品3调整到厨师2制作，这样厨师2不会闲着，总等待时间更短。 可以证明，没有更优的点餐方案。 数据规模及约定 对于100%的数据，n &lt;= 40, m &lt;= 100, p &lt;= 800, ti,j &lt;= 1000（其中p = ∑pi，即点菜同学的总人数）。 题意： n种菜m个厨师，第j个厨师做第i个菜要t[i][j]秒，每个菜点了ai份，顾客等待时间为从开始到他这份菜做完的时间，问等待总时间是多少。 思路： 与「BZOJ1070」[SCOI2007]修车类似，只是数据规模增大了。 因而，需要用到动态加点的思想。就是说，在我考虑下一个让谁做哪种的菜的时候，它只会是某一位厨师的倒数的第x道菜，因为如果让他把这道菜放在倒数第x+1道菜来做的话，肯定没有放在倒数第x道菜更优。因而，只有当一位厨师做了倒数第x道菜后（该厨师的倒数第x位置有了流量后），才允许他做倒数第x+1道菜（在菜与该厨师的倒数第x+1位置之间连边）。其他和BZOJ1070相似。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e5+20; const int INF = 1e9+7; typedef long long ll; //建边的时候建错了，以及要避免变量的重名，MCMF中的n，m不是题目给的n，m的意思 //cai是菜数，cook是厨师数，people是顾客数，sp=spend int cai,cook,sp[50][110],people; struct MCMF&#123; struct Edge&#123; int from,to,cap,cost; Edge()&#123;&#125; Edge(int from,int to,int cap,int cost):from(from),to(to),cap(cap),cost(cost)&#123;&#125; &#125;; int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn];//inqueue int d[maxn];//dis int p[maxn];//pre int a[maxn];//flow void init() &#123; for(int i=0;i&lt;=n;++i) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost) &#123; edges.push_back(Edge(from,to,cap,cost)); edges.push_back(Edge(to,from,0,-cost)); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BF(int&amp; flow,int&amp; cost) &#123; for(int i=1;i&lt;=n;++i) d[i]=INF,inq[i]=0; d[s]=0,inq[s]=1,p[s]=0,a[s]=INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); inq[u]=0; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;G[u].size()&lt;&lt;' '&lt;&lt;d[u]&lt;&lt;'\\n'; for(int i=0;i&lt;G[u].size();++i) &#123; Edge&amp; e=edges[G[u][i]]; if(e.cap&amp;&amp;d[e.to]&gt;d[u]+e.cost) &#123; d[e.to]=d[u]+e.cost; p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap); if(!inq[e.to]) &#123; Q.push(e.to); inq[e.to]=1; &#125; &#125; &#125; &#125; if(d[t]==INF) return false; flow+=a[t]; cost+=d[t]*a[t]; int u=t; while(u!=s) &#123; edges[p[u]].cap-=a[t]; edges[p[u]^1].cap+=a[t]; u=edges[p[u]].from; &#125; return true; &#125; int Mincost() &#123; int flow=0,cost=0; //cout&lt;&lt;m&lt;&lt;endl; while(BF(flow,cost)) &#123; int x=edges[p[t]].from,y=(x-cai)/people+1,z=(x-cai)%people; AddEdge(x+1,t,1,0); for(int i=1;i&lt;=cai;++i) AddEdge(i,x+1,1,((z+1)*sp[i][y])); //cout&lt;&lt;edges[p[t]].from&lt;&lt;' '&lt;&lt;flow&lt;&lt;' '&lt;&lt;cost&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl; &#125; //for(int i=1;i&lt;=10;++i) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl; return cost; &#125; &#125;NF; inline int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; //if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x; &#125; inline void readin() &#123; int temp; cai=read(),cook=read(); for(int i=1;i&lt;=cai;++i) &#123; temp=read(); NF.AddEdge(0,i,temp,0); people+=temp; &#125; NF.s=0; NF.n=NF.t=cai+people*cook+1; for(int i=1;i&lt;=cai;++i) for(int j=1;j&lt;=cook;++j) &#123; sp[i][j]=read(); NF.AddEdge(i,cai+(j-1)*people+1,1,sp[i][j]); &#125; for(int i=1;i&lt;=cook;++i) NF.AddEdge(cai+(i-1)*people+1,NF.t,1,0); &#125; int main() &#123; NF.init(); readin(); cout&lt;&lt;NF.Mincost(); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/26/BZOJ2879/","photos":[]},{"tags":[{"name":"权值线段树","slug":"权值线段树","permalink":"http://sher-wu.github.io/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"K小值","slug":"K小值","permalink":"http://sher-wu.github.io/tags/K%E5%B0%8F%E5%80%BC/"}],"title":"HDU6464","date":"2019/11/25","text":"HDU6464 免费送气球 Description 又到了GDUT一年一度的程序设计竞赛校赛的时间啦。同学们只要参加校赛，并且每解出一道题目就可以免费获得由ACM协会和集训队送出的气球一个。听到这个消息，JMC也想参加免费拿气球。可是，由于JMC太菜了而被禁止参赛，于是他找到你想让你帮忙参加比赛，可以通过执行下面的C++程序解决问题后获得气球并送给他。JMC保证了下面的程序一定能获得正确的结果。 void solve(int Q, int type[], long long first[], long long second[]) &#123; vector&lt;long long&gt; vec; for (int i = 0; i &lt; Q; ++i) &#123; if (type[i] == 1) &#123; long long k = first[i], val = second[i]; while (k--) &#123; vec.push_back(val); &#125; &#125; else if (type[i] == 2) &#123; sort(vec.begin(), vec.end()); long long l = first[i] - 1, r = second[i], res = 0; while (l &lt; r) &#123; res = (res + vec[l++]) % 1000000007; &#125; printf(\"%lld\\n\", res); &#125; &#125; &#125; 为防止你被JMC的代码搞到头晕目眩，JMC特意给出了问题的文字描述。已知一开始有一个空序列，接下来有Q次操作，每次操作给出type、first和second三个值。当type为1时，意味着该操作属于第一种操作：往序列尾部添加first个second数。当type为2时，意味着该操作属于第二种操作：查询序列中第first小至第second小的数值之和（一共有(second - first + 1)个数被累加），并将结果对1000000007取模后输出。 Input 单组数据 第一行一个Q（1 &lt;= Q &lt;= 1e5），代表Q次操作。 接下来有Q行，每行包含三个整数type、first和second；其中1 &lt;= type &lt;= 2。当type等于1时，0 &lt;= first,second &lt; 1e9。当type等于2时，1 &lt;= first &lt;= second，且first和second均不大于目前已添加进序列的数的数量。 Output 对于每次操作二，将结果对1000000007取模后输出。 Sample Input 6 1 5 1 1 6 3 2 2 5 2 4 8 1 2 2 2 4 8 Sample Output 4 11 9 思路： 可以当成权值线段树的模板的题。关键在于query的处理。 全在左直接算左儿子，全在右要减去左儿子再算右儿子。两边都有要le到左儿子右端点+右儿子左端点到ri. #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+10; const int maxm=1e9+7; typedef long long ll; struct func&#123; int type; ll fir,sec; &#125;q[maxn]; ll a[maxn],t; ll tree[4*maxn],sum[4*maxn]; void pushup(int now) &#123; tree[now]=tree[now&lt;&lt;1]+tree[now&lt;&lt;1|1]; sum[now]=(sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1])%maxm; &#125; void insert(int now,int pos,int le,int ri,int num) &#123; if(le==ri) &#123; tree[now]+=num; sum[now]=tree[now]%maxm*a[le]%maxm; return; &#125; int mid=(le+ri)&gt;&gt;1; if(pos&lt;=mid) insert(now&lt;&lt;1,pos,le,mid,num); else insert(now&lt;&lt;1|1,pos,mid+1,ri,num); pushup(now); &#125; ll query(int now,int le,int ri,ll fir,ll sec)//WA了两发的地方。没注意到fir和sec可以爆int &#123; ll sums=0; if(fir==1&amp;&amp;tree[now]==sec) return sum[now]%maxm; if(le==ri) return (sec-fir+1)%maxm*a[le]%maxm; int mid=(le+ri)&gt;&gt;1; if(sec&lt;=tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1,le,mid,fir,sec)%maxm;//关键步骤！！！ else if(fir&gt;tree[now&lt;&lt;1]) sums=query(now&lt;&lt;1|1,mid+1,ri,fir-tree[now&lt;&lt;1],sec-tree[now&lt;&lt;1])%maxm; else &#123; sums=(query(now&lt;&lt;1,le,mid,fir,tree[now&lt;&lt;1])+query(now&lt;&lt;1|1,mid+1,ri,1,sec-tree[now&lt;&lt;1]))%maxm; &#125; return sums; &#125; void run() &#123; int Q; cin&gt;&gt;Q; for(int i=1;i&lt;=Q;i++) &#123; scanf(\"%d%lld%lld\",&amp;q[i].type,&amp;q[i].fir,&amp;q[i].sec); if(q[i].type==1) a[++t]=q[i].sec; &#125; sort(a+1,a+t+1); t=unique(a+1,a+t+1)-(a+1);//WA了一发的地方。权值线段树必须要排序后去重。unique返回值的意思是剩余长度 for(int i=1;i&lt;=Q;i++) &#123; if(q[i].type==1) &#123; insert(1,lower_bound(a+1,a+t+1,q[i].sec)-a,1,t,q[i].fir); &#125; else &#123; cout&lt;&lt;query(1,1,t,q[i].fir,q[i].sec)&lt;&lt;endl; &#125; &#125; &#125; int main() &#123; run(); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/25/HDU6464/","photos":[]},{"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sher-wu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计数排序","slug":"计数排序","permalink":"http://sher-wu.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}],"title":"CF558E","date":"2019/11/24","text":"CF558E A Simple Task 5 seconds per test This task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non-decreasing order if k = 1 or in non-increasing order if k = 0. Output the final string after applying the queries. Input The first line will contain two integers n, q (1 ≤ n ≤ 105, 0 ≤ q ≤ 50 000), the length of the string and the number of queries respectively. Next line contains a string S itself. It contains only lowercase English letters. Next q lines will contain three integers each i, j, k (1 ≤ i ≤ j ≤ n, ). Output Output one line, the string S after applying the queries. Examples input 10 5 abacdabcda 7 10 0 5 8 1 1 4 0 3 6 0 7 10 1 output cbcaaaabdd input 10 1 agjucbvdfk 1 10 1 output abcdfgjkuv Note First sample test explanation: 题意：给你一串字符串，每次操作对一段区间内的字符串作升序或降序排序。输出所有操作后的字符串。 &gt;错误思路：把az依次赋以126的值，然后做区间的修改。。。写到一半就暴毙了 思路： 这是直接听归神例会讲的方法。为a~z各建立一棵线段树，然后把字符放入它自己的线段树中。每次区间排序的时候，区间求该字符的个数，区间清空，然后接着之前的顺序赋值。 比如ababa，变为升序时，t=1，1（1+3-1）变为a，然后t变为4，4（4+2-1）变为b. 复杂度O（m*26logn） #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+10; int tree[30][4*maxn],lazy[30][4*maxn]; int n,m; char c; //lazy -1 未使用, 0或1 区间赋值为0或1 void pushup(int trnum,int now) &#123; tree[trnum][now]=tree[trnum][now&lt;&lt;1]+tree[trnum][now&lt;&lt;1|1]; &#125; void pushdown(int trnum,int num,int l,int mid,int r) &#123; if(lazy[trnum][num]==0) &#123; tree[trnum][num&lt;&lt;1]=tree[trnum][num&lt;&lt;1|1]=lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=0; lazy[trnum][num]=-1; &#125; else if(lazy[trnum][num]==1) &#123; tree[trnum][num&lt;&lt;1]=mid-l+1; tree[trnum][num&lt;&lt;1|1]=r-mid; lazy[trnum][num&lt;&lt;1]=lazy[trnum][num&lt;&lt;1|1]=1; lazy[trnum][num]=-1; &#125; &#125; void addline(int trnum,int num,int le,int ri,int l,int r) &#123; if(l&gt;=le&amp;&amp;r&lt;=ri) &#123; tree[trnum][num]=r-l+1; lazy[trnum][num]=1; return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(trnum,num,l,mid,r); if(mid&gt;=le) addline(trnum,num&lt;&lt;1,le,ri,l,mid); if(mid&lt;ri) addline(trnum,num&lt;&lt;1|1,le,ri,mid+1,r); pushup(trnum,num); &#125; void add(int num,int pos,int trnum,int l,int r) &#123; if(l==r) &#123; tree[trnum][num]=1; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(num&lt;&lt;1,pos,trnum,l,mid); else add(num&lt;&lt;1|1,pos,trnum,mid+1,r); pushup(trnum,num); &#125;//其实add可以和addline合并但是当时没想到这么多就先写了个单点的 int counts(int trnum,int num,int le,int ri,int l,int r) &#123; if(l&gt;=le&amp;&amp;r&lt;=ri) &#123; lazy[trnum][num]=0; int t=tree[trnum][num]; tree[trnum][num]=0; return t; &#125; int mid=(l+r)&gt;&gt;1,sum=0; pushdown(trnum,num,l,mid,r); if(mid&gt;=le) sum+=counts(trnum,num&lt;&lt;1,le,ri,l,mid); if(mid&lt;ri) sum+=counts(trnum,num&lt;&lt;1|1,le,ri,mid+1,r); pushup(trnum,num); return sum; &#125; void run() &#123; cin&gt;&gt;n&gt;&gt;m; c=getchar(); for(int i=1;i&lt;=n;i++) &#123; c=getchar(); add(1,i,c-'a',1,n); &#125; while(m--) &#123; int le,ri,t,xu,totnum; scanf(\"%d%d%d\",&amp;le,&amp;ri,&amp;xu); if(xu) &#123; t=le; for(int i=0;i&lt;26;i++) &#123; totnum=counts(i,1,le,ri,1,n); //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;totnum&lt;&lt;endl; if(totnum) &#123; addline(i,1,t,t+totnum-1,1,n); t+=totnum; &#125; &#125; &#125; else &#123; t=ri; for(int i=0;i&lt;26;i++) &#123; totnum=counts(i,1,le,ri,1,n); //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;totnum&lt;&lt;endl; if(totnum) &#123; addline(i,1,t-totnum+1,t,1,n); t-=totnum; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;26;j++) &#123; if(counts(j,1,i,i,1,n)) &#123; printf(\"%c\",'a'+j); break; &#125; //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; &#125; &#125; &#125; void init() &#123; memset(lazy,-1,sizeof(lazy)); &#125; int main() &#123; if(fopen(\"test.txt\",\"r\")!=NULL) freopen(\"test.txt\",\"r\",stdin); init(); run(); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/24/CF558E/","photos":[]},{"tags":[{"name":"位运算","slug":"位运算","permalink":"http://sher-wu.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"}],"title":"CF1174D","date":"2019/11/23","text":"CF1174D Ehab and the Expected XOR Problem Description Given two integers n and x, construct an array that satisfies the following conditions: for any element ai in the array, \\(1&lt;=ai&lt;2n\\); there is no non-empty subsegment with bitwise XOR equal to 0 or x, its length l should be maximized. A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Input The only line contains two integers n and x (1≤n≤18, 1≤x&lt;218). Output The first line should contain the length of the array l. If l is positive, the second line should contain l space-separated integers a1, a2, …, al (1≤ai&lt;2n) — the elements of the array a. If there are multiple solutions, print any of them. Examples input 3 5 output 3 6 1 3 input 2 4 output 3 1 3 1 input 1 1 output 0 Note In the first example, the bitwise XOR of the subsegments are {6,7,4,1,2,3}. 题意： 构造一个数列，元素为1~2^n的数，使得数列的任意子段的XOR和均不等于0与X。求数列的长度和任意一个解。 思路： 最重要的：想到取构造前缀XOR和数组，而非直接去构造数组ai。 具体的：构造前缀XOR和数组bi，则alal+1···ar=bl-1br.则不等于0-&gt;任意的bi与bj不相等。不等于X-&gt;若bi^bj=X，则只能取其一（代码中取了更小的）。遍历一遍所有数即可。然后用前缀数组算出原数组。 时间复杂度O（2^n） #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; typedef long long ll; const int maxn &#x3D; 3e6+10; int n,x,t[maxn],num,f[20],cou[maxn];&#x2F;&#x2F;cou为输出，t[i]&#x3D;1表示数组b不能选i，实际上用一个即可 int main() &#123; cin&gt;&gt;n&gt;&gt;x; t[0]&#x3D;t[x]&#x3D;1; for(int i&#x3D;1;i&lt;(ll)(pow(2,n));i++) if(t[i]&#x3D;&#x3D;0) cou[++num]&#x3D;i,t[x^i]&#x3D;1;&#x2F;&#x2F;i^j&#x3D;x &lt;&#x3D;&#x3D;&gt; i^x&#x3D;j ,让之后选的数不为i^x或x就行 cout&lt;&lt;num&lt;&lt;endl; if(num!&#x3D;0) cout&lt;&lt;cou[1]&lt;&lt;&#39; &#39;; for(int i&#x3D;1;i&lt;num;i++) cout&lt;&lt;(cou[i]^cou[i+1])&lt;&lt;&#39; &#39;; return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/23/CF1174D/","photos":[]},{"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sher-wu.github.io/tags/DFS/"},{"name":"分治","slug":"分治","permalink":"http://sher-wu.github.io/tags/%E5%88%86%E6%B2%BB/"}],"title":"GYM101915K","date":"2019/11/18","text":"GYM101915K Chess Positions Description 一串01串，将其分成多个（可以为1）个区间，分别求和，要求所得的串是回文的。求总的种类数，结果对1e9+7取模 Input The first line contains a single integer T denoting the number of test cases. Each test case consists of one line which contains the original sequence of zeros and ones. The length of every sequence is less than or equal to 50. Output For each test print one line containing one integer, the number of different ways to divide the original sequence leading to a sumindrome sequence modulo (1e9+7). Sample Input 2 0110 1001 Sample Output 4 8 Note The ways of dividing the sequence in the second sample are: -&gt; 2 (1)(001) -&gt; 1, 1 (100)(1) -&gt; 1, 1 (10)(01) -&gt; 1, 1 (1)(00)(1) -&gt; 1, 0, 1 (1)(0)(01) -&gt; 1, 0, 1 (10)(0)(1) -&gt; 1, 0, 1 (1)(0)(0)(1) -&gt; 1, 0, 0, 1 思路： 回文数的要求就是从左和从右一样，那么从左开始和从右开始的总值一样时，就把这些值合并，再求剩下里面的回文的种类数。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll maxn=1e9+7; char a[60]; int dp[60][60]; void init() &#123; memset(dp,-1,sizeof(dp)); &#125; ll dfs(int l,int r) &#123; //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;'\\n'; if(l&gt;=r) return dp[l][r]=1; if(dp[l][r]!=-1) return dp[l][r]; int &amp;tent=dp[l][r]=1;//这一块全部加起来作为中间项必定正确 int suml=0; for(int i=l;i&lt;r;i++) &#123; suml+=a[i]-'0'; int sumr=0; for(int j=r;j&gt;i;j--) &#123; sumr+=a[j]-'0'; if(suml&lt;sumr) break; if(suml==sumr) tent=(tent+dfs(i+1,j-1))%maxn; &#125; &#125; return tent; &#125; int main() &#123; //freopen(\"text.txt\",\"r\",stdin); int t; cin&gt;&gt;t; while(t--) &#123; init(); scanf(\"%s\",a); printf(\"%lld\\n\",dfs(0,strlen(a)-1)); &#125; &#125;","permalink":"http://sher-wu.github.io/2019/11/18/GYM101915K/","photos":[]},{"tags":[{"name":"离散化","slug":"离散化","permalink":"http://sher-wu.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"搜索","permalink":"http://sher-wu.github.io/tags/%E6%90%9C%E7%B4%A2/"}],"title":"CF1119D","date":"2019/11/17","text":"CF1119D Frets On Fire Description Miyako came to the flea kingdom with a ukulele. She became good friends with local flea residents and played beautiful music for them every day. In return, the fleas made a bigger ukulele for her: it has n strings, and each string has (1018+1) frets numerated from 0 to 1018. The fleas use the array s1,s2,…,sn to describe the ukulele's tuning, that is, the pitch of the j-th fret on the i-th string is the integer si+j. Miyako is about to leave the kingdom, but the fleas hope that Miyako will answer some last questions for them. Each question is in the form of: \"How many different pitches are there, if we consider frets between l and r (inclusive) on all strings?\" Miyako is about to visit the cricket kingdom and has no time to answer all the questions. Please help her with this task! Formally, you are given a matrix with n rows and (1018+1) columns, where the cell in the i-th row and j-th column (0≤j≤1018) contains the integer si+j. You are to answer q queries, in the k-th query you have to answer the number of distinct integers in the matrix from the lk-th to the rk-th columns, inclusive. Input The first line contains an integer n (1≤n≤100000) — the number of strings. The second line contains n integers s1,s2,…,sn (0≤si≤1018) — the tuning of the ukulele. The third line contains an integer q (1≤q≤100000) — the number of questions. The k-th among the following q lines contains two integers lk，rk (0≤lk≤rk≤1018) — a question from the fleas. Output Output one number for each question, separated by spaces — the number of different pitches. Examples input 6 3 1 4 1 5 9 3 7 7 0 2 8 17 output 5 10 18 input 2 1 500000000000000000 2 1000000000000000000 1000000000000000000 0 1000000000000000000 output 2 1500000000000000000 题意： 有n个以ai开头，依次+1的数列，问在每个数列中去li~ri项，总共有多少不相同的项 思路： li与ri怎么取并没有意义，只有长度才有意义。 排序后求差，当长度-1&gt;=两相邻数之差时,小的数将没有贡献。 Ⅰ 用离散化的方法，对差排序后对其进行叠加及保存(dxr用的&lt;1&gt;，且省去了离散化） Ⅱ &lt;1&gt; c[i] = b[i] + c[i-1] (b是差的排序数组） 前后两数之差大于len的，都有贡献，小于len的全体，有c[i]的贡献 Ⅱ &lt;2&gt; ans[num[i]]=ans[num[i-1]]+tot(num[i]-num[i-1]) (tot当前仍有贡献的数的个数)，用rec[i]来保存) out[k]=ans[num[pos]]+(res[num[pos]])*(len-num[pos]) 所求 = num[i]的总贡献+(len-num[i])间有效数个数长度 DXR &lt;1&gt; : //总的来说，就是差大于len的，都有贡献，小于len的全体，有c[i]的贡献 //有一个极大的好处，就是没有用到离散化的知识点 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; typedef unsigned long long ull; const int NN = 110000; int n, num; ull b[NN], c[NN], tmp, h, len, l, r, ans, m, a[NN]; bool cmp(ull a, ull b) &#123; return a &lt; b; &#125; int main() &#123; //freopen(\"1.in\", \"r\", stdin); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%llu\", &amp;a[i]); &#125; //首先对a排序 sort(a + 1, a + n + 1, cmp); num = 0; for (int i = 2; i &lt;= n; i++) if (a[i] - a[i - 1]) b[++num] = a[i] - a[i - 1]; //求两个大小相邻的，不同的数字之间（去重）的差 sort(b + 1, b + num + 1, cmp); //对差排序，求部分和（因为差&lt;len的所有点都有部分重复，需要减去） c[0] = 0; for (int i = 1; i &lt;= num; i++) c[i] = b[i] + c[i - 1]; //len到b[i]时，该数与该数-1有b[i]未重合 //c[i]表示到第i个数时，如果len&gt;=b[i]，前面所有数的获得的有效数的总数 /* for (int i=1; i&lt;=n; i++) printf(\"%d \", a[i]); printf(\"\\n\"); for (int i=1; i&lt;=num; i++) printf(\"%d \", b[i]); printf(\"\\n\"); for (int i=1; i&lt;=num; i++) printf(\"%d \", c[i]); printf(\"\\n\"); */ scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%llu%llu\", &amp;l, &amp;r); len = r - l + 1; //由题目，最终答案与起点终点无关，至于起点与终点之间的距离有关 //由题, 每个点与上一个点重复的个数=len-它与上一个点的差（若差&gt;=len, 则无重复点） //num是差的个数，有效数的总数为num+1 ans = (num + 1) * len; //先将每个数字可以引出的新数都算上（很可能中间有重复的） tmp = lower_bound(b + 1, b + num + 1, len) - b; //找到比len小的最大的差，即为（tmp-1）， ans -= len * (tmp - 1) - c[tmp - 1]; //减去重复的个数（每个点仅考虑与上一个点重复的） //假设所有&lt;len的数都产生了重复，全部删去，再补上实际上未产生重复的 //printf(\"\\n%llu\\n\", tmp); printf(\"%llu \", ans); &#125; return 0; &#125; MS &lt;1&gt; : //离线完成，极大的降低了复杂度 #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; typedef long long ll; typedef pair&lt;ll, ll&gt; P; typedef pair&lt;P, int&gt; PP; const int maxn = 1e5 + 100; ll a[maxn], b[maxn]; P ans[maxn]; PP q[maxn]; bool cmp(PP p1, PP p2) &#123; if (p1.first.second - p1.first.first &lt; p2.first.second - p2.first.first) return 1; else return 0; &#125; bool cmp1(PP p1, PP p2) &#123; if (p1.second &lt; p2.second) return 1; else return 0; &#125; int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0; i &lt; n - 1; i++) b[i] = (a[i + 1] - a[i]); sort(b, b + n - 1); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; q[i].first.first &gt;&gt; q[i].first.second; q[i].second = i; &#125; sort(q, q + t, cmp); ll now = 0, coun = 0; for (int i = 0; i &lt; t; i++) &#123; ll cha = q[i].first.second - q[i].first.first + 1; while (coun != n - 1 &amp;&amp; cha &gt;= b[coun]) &#123; now += b[coun]; coun++; &#125; ans[i].first = q[i].second; ans[i].second = now + cha * (n - coun); &#125; sort(ans, ans + t); for (int i = 0; i &lt; t; i++) &#123; cout &lt;&lt; ans[i].second &lt;&lt; \" \"; &#125; &#125; YZM &lt;2&gt; : #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e5 + 10; typedef long long ll; int n, q, tot; ll s[maxn]; ll l, r, len; map&lt;ll, ll&gt; vis, res, ans; ll num[maxn], cnt; ll out[maxn]; int main() &#123; cin &gt;&gt; n; tot = n; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", &amp;s[i]); sort(s + 1, s + n + 1); for (int i = 1; i &lt; n; ++i) &#123; ll p = s[i + 1] - s[i]; if (!p) tot--; else if (!vis[p]) num[++cnt] = p; //用num保存所有的数 vis[p]++; &#125; //for(map&lt;ll,ll&gt;::iterator it=vis.begin();it!=vis.end();it++) //printf(\"%I64d:%I64d\\n\",it-&gt;first,it-&gt;second); sort(num + 1, num + cnt + 1); ans[0] = num[0] = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; ans[num[i]] = ans[num[i - 1]] + tot * (num[i] - num[i - 1]); //到num[i]这个数为止，所有数的贡献=上一段的贡献+num[i-1]+1到num[i]间有效数的贡献 //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;ans[num[i]]&lt;&lt;endl; res[num[i - 1]] = tot; tot -= vis[num[i]]; //tot为下一段中仍有贡献的数的个数 &#125; res[num[cnt]] = tot; //for(int i=0;i&lt;=cnt;++i) //printf(\"-&gt;%I64d:%I64d + %I64d\\n\",num[i],ans[num[i]],res[num[i]]); scanf(\"%d\", &amp;q); for (int k = 1; k &lt;= q; ++k) &#123; scanf(\"%lld%lld\", &amp;l, &amp;r); len = r - l + 1; int pos = upper_bound(num, num + cnt + 1, len) - num; pos--; //num[pos]&lt;=len //cout&lt;&lt;pos&lt;&lt;endl; //printf(\"pos:%d\\n\",pos); //printf(\"v:%I64d +:%I64d\\n\",ans[num[pos]],res[num[pos]]); out[k] = ans[num[pos]] + (res[num[pos]]) * (len - num[pos]); &#125; for (int k = 1; k &lt;= q; ++k) printf(\"%lld \", out[k]); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/17/CF1119D/","photos":[]},{"tags":[{"name":"DP","slug":"DP","permalink":"http://sher-wu.github.io/tags/DP/"}],"title":"PTA-L3-20","date":"2019/11/15","text":"PTA-L3-20 至多删三个字符 Description 给定一个全部由小写英文字母组成的字符串，允许你至多删掉其中3个字符，结果可能有多少种不同的字符串？ Input 输入在一行中给出全部由小写英文字母组成的、长度在区间 [4, 1e6​​] 内的字符串。 Output 在一行中输出至多删掉其中 3 个字符后不同字符串的个数。 Sample Input ababcc Sample Output 25 Hint 删掉 0 个字符得到 \"ababcc\"。 删掉 1 个字符得到 \"babcc\", \"aabcc\", \"abbcc\", \"abacc\" 和 \"ababc\"。 删掉 2 个字符得到 \"abcc\", \"bbcc\", \"bacc\", \"babc\", \"aacc\", \"aabc\", \"abbc\", \"abac\" 和 \"abab\"。 删掉 3 个字符得到 \"abc\", \"bcc\", \"acc\", \"bbc\", \"bac\", \"bab\", \"aac\", \"aab\", \"abb\" 和 \"aba\"。 思路： 为了避免重复，以及枚举或者组合数在此用起来不现实，因而使用DP。 d[i][j]表示前i个字符中删除j个字符后得到的不同字符串的个数。则 d[i][j+1]+=d[i-1][j]（删除第i个字符）&amp;&amp; d[i][j]+=d[i-1][j]（不删除第i个字符） 如果只是这样转移肯定会有重复的。例如一个字符串cdabnaxy，你删除abn和删除bna后得到的字符串都是cdaxy。 这时候就要去重了，根据上面那个栗子可以发现对于一个字符s[i]，如果在i之前存在一个x使得s[x]==s[i]，那么删除[x,i-1]间的字符和删除[x+1,i]间的字符其实是重复的，等价的，那么d[i][j]就要减去d[x-1][j-(i-x)]，减去删除这段造成的重复串。 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAX = 1e6 + 5; typedef long long ll; char s[MAX]; ll d[MAX][4]; int main() &#123; scanf(\"%s\", s + 1); int n = strlen(s + 1); d[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= 3; j++) &#123; if (d[i - 1][j] == 0) continue; if (j &lt; 3) d[i][j + 1] += d[i - 1][j]; d[i][j] += d[i - 1][j]; for (int k = i - 1; k &gt;= 1 &amp;&amp; i - k &lt;= j; k--) //往前找到第一个k使得s[k]=s[i] &#123; if (s[k] == s[i]) &#123; d[i][j] -= d[k - 1][j - (i - k)]; break; &#125; &#125; &#125; &#125; printf(\"%lld\\n\", d[n][0] + d[n][1] + d[n][2] + d[n][3]); return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/15/PTA-L3-20/","photos":[]},{"tags":[{"name":"构造","slug":"构造","permalink":"http://sher-wu.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"贪心","slug":"贪心","permalink":"http://sher-wu.github.io/tags/%E8%B4%AA%E5%BF%83/"}],"title":"CF1041E","date":"2019/11/14","text":"CF Round #509 (Div.2) E. Tree Reconstruction Description 1 second per test Monocarp has drawn a tree (an undirected connected acyclic graph) and then has given each vertex an index. All indices are distinct numbers from 1 to n. For every edge e of this tree, Monocarp has written two numbers: the maximum indices of the vertices of the two components formed if the edge e (and only this edge) is erased from the tree. Monocarp has given you a list of n−1 pairs of numbers. He wants you to provide an example of a tree that will produce the said list if this tree exists. If such tree does not exist, say so. Input The first line contains one integer n (2≤n≤1000) — the number of vertices in the tree. Each of the next n−1 lines contains two integers ai and bi each (\\(1&lt;=ai&lt;bi&lt;=n\\)) — the maximal indices of vertices in the components formed if the i-th edge is removed. Output If there is no such tree that can produce the given list of pairs, print \"NO\" (without quotes). Otherwise print \"YES\" (without quotes) in the first line and the edges of the tree in the next n−1 lines. Each of the last n−1 lines should contain two integers xi and yi (1≤xi,yi≤n) — vertices connected by an edge. Note: The numeration of edges doesn't matter for this task. Your solution will be considered correct if your tree produces the same pairs as given in the input file (possibly reordered). That means that you can print the edges of the tree you reconstructed in any order. Examples input 4 3 4 1 4 3 4 output YES 1 3 3 2 2 4 input 3 1 3 1 3 output NO input 3 1 2 2 3 output NO Note Possible tree from the first example. Dotted lines show edges you need to remove to get appropriate pairs. Example 题意： 是说，要构建一个树，使得它砍掉每一条边时，左右的最大权值是给定的值。 例如样例1，4-2-3-1，砍第一二条边左右最大都是4&amp;3，砍第三条是4&amp;1，符合题意，然后输出每一条边的左右节点。 思路： 最最最基本的，它的某一边最大一定是n，否则直接No。 如果n，x只出现了一次，那直接n，x相连即可。 如果出现了两次，那么要在n与x中间加一个比x小的数i。 如果三次。。。 那么就直接是贪心，从最小的x开始，i也从1开始递增，根据n，x出现的次数多少决定在n，x中间加多少个数（次数-1）。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,a[1010],b[1010],c[1010],now,add[1010],nown=1; int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(x==n) a[y]++;//（x,n）中x的出现次数 else if(y==n) a[x]++; else &#123; cout&lt;&lt;\"NO\"; return 0; &#125; &#125; int ch=1; for(int i=1;i&lt;n;i++) &#123; if(a[i])//没有就跳过 &#123; int t=n; while(a[i]&gt;1&amp;&amp;nown&lt;=i)//是1，直接建边 &#123; if(add[nown]==0)&#123; b[++now]=t; c[now]=nown; add[nown]=1; t=nown; a[i]--; &#125; nown++; &#125; if(nown&gt;i)//不是1，先往小的连，到1以后，再建边 &#123; ch=0; break; &#125; b[++now]=t; c[now]=i; add[i]=1; a[i]--; &#125; &#125; if(ch==0)//（x,n）的次数少于剩余的小于x的数的总数了，No &#123; cout&lt;&lt;\"NO\"; &#125; else &#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; for(int i=1;i&lt;n;i++) &#123; cout&lt;&lt;b[i]&lt;&lt;' '&lt;&lt;c[i]&lt;&lt;endl; &#125; &#125; return 0; &#125;","permalink":"http://sher-wu.github.io/2019/11/14/CF1041E/","photos":[]},{"tags":[{"name":"模拟","slug":"模拟","permalink":"http://sher-wu.github.io/tags/%E6%A8%A1%E6%8B%9F/"}],"title":"PTA-L1-64","date":"2019/11/13","text":"PTA-L1-64 估值一亿的AI核心代码 Description 本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是： 无论用户说什么，首先把对方说的话在一行中原样打印出来； 消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉； 把原文中所有大写英文字母变成小写，除了 I； 把原文中所有独立的 can you、could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词； 把原文中所有独立的 I 和 me 换成 you； 把原文中所有的问号 ? 换成惊叹号 !； 在一行中输出替换后的句子作为 AI 的回答。 Input 输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。 Output 按题面要求输出，每个 AI 的回答前要加上 AI: 和一个空格。 输入样例： 6 Hello ? Good to chat with you can you speak Chinese? Really? Could you show me 5 What Is this prime? I,don 't know 输出样例： Hello ? AI: hello! Good to chat with you AI: good to chat with you can you speak Chinese? AI: I can speak chinese! Really? AI: really! Could you show me 5 AI: I could show you 5 What Is this prime? I,don 't know AI: what Is this prime! you,don't know 第一次出去比赛，rating拿了全组第一还是挺开心的。 代码就懒得再写一遍了。讲白了就是一道码农模拟题，难点也主要就在特判怎么设。 &gt; 1、从头开始检测空格，检测的连续的两个空格就连删直到只剩一个（用了char的strcpy，string的erase应该也行） 2、删头尾的空格，与字符前面的空格 3、变换所有大写字母与？-&gt;! 4、开始输出 { Ⅰ 输出个 ’AI: ‘ Ⅱ 一位一位输出直到 a[i]==’\\0' Ⅲ 用连续的字符特判判定 “can you”&amp;&amp;“could you”，并使I+=7,i+=9; Ⅳ 判定I&amp;&amp;me前后是不是字符(是否独立） *A:65 a:97 0:48 Ⅴ 输出’‘ }","permalink":"http://sher-wu.github.io/2019/11/13/PTA-L1-64/","photos":[]},{"tags":[{"name":"Introduct","slug":"Introduct","permalink":"http://sher-wu.github.io/tags/Introduct/"}],"title":"Hello World","date":"2019/11/11","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","permalink":"http://sher-wu.github.io/2019/11/11/Hello%20World/","photos":[]}]}